<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aether: The Flow State</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #F4F7F2;
            font-family: 'Montserrat', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            cursor: crosshair;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px 30px;
            color: #2F6F6F;
            text-shadow: 0 2px 4px rgba(255,255,255,0.8);
        }

        .score-block {
            text-align: left;
        }

        .score-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .score-val {
            font-size: 32px;
            font-weight: 900;
            letter-spacing: 1px;
        }

        .highscore-in-game {
            font-size: 0.9rem;
            color: #E9C46A;
            font-weight: 700;
            margin-top: 2px;
        }

        .currency-display {
            font-size: 16px;
            font-weight: 700;
            color: #E9C46A;
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .energy-wrapper {
            text-align: right;
        }

        .energy-bar-container {
            width: 200px;
            height: 12px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #2F6F6F;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #energy-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #2A9D8F, #2F6F6F);
            transition: width 0.1s linear;
        }

        /* Boss HUD */
        #boss-hud {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            display: none; 
            flex-direction: column;
            align-items: center;
        }
        .boss-name {
            color: #8B0000;
            font-weight: 900;
            font-size: 1.5rem;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,0,0,0.5);
            margin-bottom: 5px;
        }
        .boss-hp-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #8B0000;
            border-radius: 10px;
            overflow: hidden;
        }
        #boss-hp-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #FF4500, #8B0000);
            transition: width 0.2s;
        }
        
        #mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
            background: rgba(255,255,255,0.8);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        #mute-btn:active {
            transform: scale(0.9);
        }

        #attack-btn {
            position: absolute;
            bottom: 40px;
            left: 30px;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: #E76F51;
            border: 4px solid #fff;
            color: white;
            font-weight: 900;
            font-size: 1.2rem;
            display: none; 
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            align-items: center;
            justify-content: center;
        }
        #attack-btn:active { transform: scale(0.95); background: #d65d40; }

        /* QTE/Slow Motion Elements removed */

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(244, 247, 242, 0.95);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            pointer-events: auto;
            transition: opacity 0.4s, transform 0.4s;
            z-index: 10;
            box-sizing: border-box;
            overflow-y: auto; 
            touch-action: pan-y;
            justify-content: flex-start;
            padding-top: 40px;
            padding-bottom: 40px;
            -webkit-overflow-scrolling: touch;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
            z-index: -1;
        }

        .modal-overlay {
            background: rgba(0, 0, 0, 0.6);
            z-index: 100;
            justify-content: center;
            padding-top: 0;
        }

        h1 {
            color: #2F6F6F;
            font-size: 3.5rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.1);
            line-height: 1;
        }

        h2 {
            color: #4A5A6A;
            font-size: 1.2rem;
            margin: 10px 0 30px 0;
            font-weight: 400;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        h3 {
            color: #2F6F6F;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(47, 111, 111, 0.2);
            padding-bottom: 5px;
            display: inline-block;
        }
        
        p {
            color: #556677;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 320px;
            margin-bottom: 40px;
        }

        .btn {
            background: #2F6F6F;
            color: #F4F7F2;
            border: none;
            padding: 16px 30px;
            font-size: 1.1rem;
            font-weight: 800;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            box-shadow: 0 5px 15px rgba(47, 111, 111, 0.3);
            font-family: 'Montserrat', sans-serif;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(47, 111, 111, 0.4);
            background: #265959;
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(47, 111, 111, 0.3);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #2F6F6F;
            color: #2F6F6F;
            box-shadow: none;
        }
        .btn-secondary:hover {
            background: rgba(47, 111, 111, 0.05);
            color: #1a4040;
        }

        .btn-shop {
            background: #E9C46A;
            color: #1A2B3C;
            border: none;
        }
        .btn-shop:hover {
            background: #d4b058;
        }
        
        .btn-option {
            background: white;
            color: #2F6F6F;
            border: 2px solid #eee;
            text-transform: none;
            font-size: 0.95rem;
            padding: 12px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-bottom: 10px;
            text-align: left;
            line-height: 1.4;
            width: 100%;
            cursor: pointer;
        }
        .btn-option:hover {
            background: #f4f7f2;
            border-color: #2F6F6F;
            transform: translateY(-1px);
        }

        /* Info Panels */
        .info-panel {
            background: white;
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(47, 111, 111, 0.08);
            max-width: 650px;
            width: 90%;
            text-align: left;
            margin-bottom: 20px;
        }
        
        .info-list li {
            margin-bottom: 8px;
            color: #556677;
            list-style-type: none;
            position: relative;
            padding-left: 20px;
            font-size: 0.95rem;
        }
        .info-list li::before {
            content: '‚Ä¢'; color: #2F6F6F; font-weight: bold; position: absolute; left: 0;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .feature-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: rgba(244, 247, 242, 0.5);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer; 
        }

        .icon-circle {
            font-size: 24px;
            margin-bottom: 5px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        /* Shop Styles */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 600px;
            padding: 10px;
        }

        .shop-item {
            background: white;
            border-radius: 15px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            border: 3px solid transparent;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .shop-item:hover {
            transform: translateY(-2px);
        }

        .shop-item.active {
            border-color: #2F6F6F;
            background: #F0FAF9;
        }

        .skin-preview {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-bottom: 10px;
            border: 2px solid #eee;
        }

        .skin-name {
            font-weight: 800;
            color: #2F6F6F;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .skin-perk {
            font-size: 0.75rem;
            color: #556677;
            margin-bottom: 10px;
            min-height: 30px;
        }

        .skin-price {
            font-weight: bold;
            color: #E9C46A;
            background: #1A2B3C;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }
        
        .owned-tag {
            background: #2A9D8F;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            align-items: center;
            margin-bottom: 15px;
            background: white;
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        /* Badges */
        .badge-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .badge {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: #ccc;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
            filter: grayscale(1);
            opacity: 0.5;
            position: relative;
        }
        .badge.unlocked {
            filter: grayscale(0);
            opacity: 1;
            background: #FFD700;
            box-shadow: 0 0 10px gold;
        }

        /* Flash Effect */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(231, 111, 81, 0.4) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
            z-index: 4;
        }

        .stat-badge {
            background: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 900;
            color: #E9C46A;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            font-size: 1rem;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; letter-spacing: 4px; }
            h2 { font-size: 1rem; margin-bottom: 20px; }
            .shop-grid { grid-template-columns: 1fr; }
            .feature-grid { grid-template-columns: 1fr; gap: 10px; }
            .feature-item { flex-direction: row; gap: 15px; text-align: left; }
            .screen { backdrop-filter: blur(5px); }
            .btn { padding: 18px 30px; font-size: 1.2rem; }
            .btn-option { padding: 15px 20px; font-size: 1rem; }
            #mute-btn { bottom: 30px; right: 30px; width: 60px; height: 60px; }
            
            /* Hide keyboard controls hint on mobile */
            #controls-hint {
                display: none !important;
            }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="damage-overlay"></div>
    
    <!-- QTE OVERLAY REMOVED -->

    <div id="boss-hud">
        <div class="boss-name">NEMESIS A.I.</div>
        <div class="boss-hp-bar">
            <div id="boss-hp-fill"></div>
        </div>
    </div>

    <button id="mute-btn" onclick="toggleAudio()">üîä</button>
    <div id="attack-btn" onclick="playerAttack()">‚öîÔ∏è</div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-block">
                <div class="score-label">Distance</div>
                <div class="score-val"><span id="score">0</span>m</div>
                <div class="highscore-in-game">Best: <span id="hud-highscore">0</span>m</div>
            </div>
            <div class="energy-wrapper">
                <div class="score-label">Comfort (Energy)</div>
                <div class="energy-bar-container">
                    <div id="energy-fill"></div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; padding-bottom: 20px; opacity: 0.6; font-size: 0.8rem; color: #2F6F6F;" id="controls-hint">
            Space/Up/W: Jump | Down/S: Dive
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <div style="font-size: 60px; color: #2F6F6F; margin-bottom: 10px;">‚ö°</div>
        <h1>AETHER</h1>
        <h2>Endless Climate Run</h2>
        <div class="stat-badge">BEST: <span id="menu-highscore">0</span>m</div>
        <div class="currency-display" style="font-size: 1.2rem; margin-bottom: 20px;">
            <span id="menu-coins">0</span> Aether Coins
        </div>
        
        <div class="badge-grid" id="badge-container"></div>

        <div class="btn-group">
            <button class="btn" onclick="startGame()">Start Running</button>
            <button class="btn btn-secondary" onclick="cycleDifficulty()" id="diff-btn">Difficulty: Medium</button>
            <button class="btn btn-shop" onclick="openShop()">Aether Shop</button>
            <button class="btn btn-secondary" onclick="showScreen('product-screen')">Our Technology</button>
            <button class="btn btn-secondary" onclick="showScreen('instructions-screen')">How to Play</button>
        </div>
        <div style="opacity: 0.5; font-size: 0.8rem; margin-bottom: 20px;">v8.5 - Obstacle Refactor</div>
    </div>

    <!-- Win Screen (Remains for high score milestones) -->
    <div id="win-screen" class="screen hidden" style="justify-content: center; background: rgba(255,255,255,0.95);">
        <h1 style="color: #E9C46A; font-size: 4rem;">MILESTONE</h1>
        <h2 style="color: #2F6F6F;">20,000M REACHED</h2>
        <p>You have achieved maximum distance flow.</p>
        <div class="btn-group">
            <button class="btn" onclick="continueEndless()">Continue (Endless)</button>
            <button class="btn btn-secondary" onclick="endGame('Milestone Complete')">Finish Run</button>
        </div>
    </div>

    <!-- Product Page -->
    <div id="product-screen" class="screen hidden">
        <h2 style="margin-bottom: 5px; color: #E9C46A; font-size: 1rem; letter-spacing: 3px;">SUSTAINABLE PERFORMANCE</h2>
        <h1>AETHER TECH</h1>
        <div class="info-panel">
            <h3>The Seaweed x Merino Fusion</h3>
            <p>We've engineered the ultimate sportswear fabric by blending <strong>nutrient-rich Seaweed</strong> with <strong>premium Merino Wool</strong>.</p>
            <div class="feature-grid">
                <div class="feature-item">
                    <div class="icon-circle" style="color:#2F6F6F">üåø</div>
                    <div><strong>Bio-Active</strong><br><span style="font-size:0.8em">Seaweed transfers nutrients to skin.</span></div>
                </div>
                <div class="feature-item">
                    <div class="icon-circle" style="color:#E9C46A">‚òÄÔ∏è</div>
                    <div><strong>UV Shield</strong><br><span style="font-size:0.8em">Natural protection from solar rays.</span></div>
                </div>
                <div class="feature-item">
                    <div class="icon-circle" style="color:#2A9D8F">üí®</div>
                    <div><strong>Air-Woven</strong><br><span style="font-size:0.8em">3-Layer structure for max airflow.</span></div>
                </div>
            </div>
            <h3 style="margin-top: 20px;">The 3-Layer Structure</h3>
            <ul class="info-list">
                <li><strong>Inner Layer (Merino):</strong> Ultra-soft, antibacterial, and moisture-wicking.</li>
                <li><strong>Middle Layer (Air Pockets):</strong> Micro-cavities trap air for insulation.</li>
                <li><strong>Outer Layer (Wave Weave):</strong> A durable, wave-patterned shield.</li>
            </ul>
        </div>
        <button class="btn" style="max-width: 200px;" onclick="showScreen('start-screen')">Back to Menu</button>
    </div>

    <!-- Quiz Overlay (Still present, but simplified activation) -->
    <div id="quiz-screen" class="screen hidden" style="z-index: 50; justify-content: center;">
        <h2 style="color: #2F6F6F; margin-bottom: 10px;">AETHER TRIVIA</h2>
        <p>Answer correctly for <strong>50 Coins</strong> & a <strong>Powerup</strong>!</p>
        <div class="info-panel" style="width: 100%; max-width: 500px;">
            <h3 id="quiz-question" style="margin-bottom: 20px;">Question goes here...</h3>
            <div id="quiz-options" style="display: flex; flex-direction: column; gap: 10px;"></div>
        </div>
    </div>

    <!-- Reward Overlay -->
    <div id="reward-screen" class="screen hidden" style="z-index: 51; justify-content: center;">
        <h1 style="font-size: 2.5rem; color: #E9C46A;">CORRECT!</h1>
        <p>+50 Coins Added! Choose your buff:</p>
        <div class="feature-grid" style="margin-top: 10px;">
            <div class="feature-item" onclick="applyBuff('MAGNET')">
                <div class="icon-circle">üß≤</div>
                <div><strong>Magnet</strong><br>Attract Items (Permanent)</div>
            </div>
            <div class="feature-item" onclick="applyBuff('SHIELD_REGEN')">
                <div class="icon-circle">üõ°Ô∏è</div>
                <div><strong>Regen</strong><br>Shields Restore (Permanent)</div>
            </div>
            <div class="feature-item" onclick="applyBuff('EFFICIENCY')">
                <div class="icon-circle">üîã</div>
                <div><strong>Efficient</strong><br>Slower Drain (Permanent)</div>
            </div>
            <div class="feature-item" onclick="applyBuff('INVULNERABILITY')">
                <div class="icon-circle">‚ú®</div>
                <div><strong>Invincible</strong><br>3s Immunity (Temporary)</div>
            </div>
            <div class="feature-item" onclick="applyBuff('COIN_DOUBLER')">
                <div class="icon-circle">üíé</div>
                <div><strong>Doubler</strong><br>15s 2x Coins (Temporary)</div>
            </div>
        </div>
    </div>

    <!-- Shop Screen -->
    <div id="shop-screen" class="screen hidden">
        <div class="shop-header">
            <h2 style="margin:0;">Aether Wardrobe</h2>
            <div class="currency-display"><span id="shop-coins">0</span> ü™ô</div>
        </div>
        <div id="shop-container" class="shop-grid"></div>
        <div class="btn-group" style="margin-top: 20px;">
            <button class="btn btn-secondary" onclick="showScreen('start-screen')">Back to Menu</button>
        </div>
    </div>

    <!-- Instructions Page -->
    <div id="instructions-screen" class="screen hidden">
        <h1>Field Guide</h1>
        <div class="info-panel" style="max-height: 70vh; overflow-y: auto;">
            <div class="feature-grid" style="margin-bottom: 20px;">
                <div class="feature-item">
                    <div class="icon-circle">üëÜ</div>
                    <div><strong>Tap / Swipe Up</strong><br>Jump</div>
                </div>
                <div class="feature-item">
                    <div class="icon-circle">üëá</div>
                    <div><strong>Swipe Down</strong><br>Dive</div>
                </div>
            </div>
            
            <h3>Hazards & Threats (Energy Loss)</h3>
            <ul class="info-list">
                <li><strong>Stiff Nylon Tag:</strong> Standard ground obstacle (synthetic discomfort).</li>
                <li><strong>Plastic Bale (Landfill):</strong> Taller ground hazard (landfill waste).</li>
                <li><strong>Air Pollution (Smog Zone):</strong> Floating cloud that drains Comfort rapidly.</li>
                <li><strong>Ocean Waste (Plastic Bottle):</strong> Erratic, fast-moving projectile (fiber shedding).</li>
                <li><strong>CO2 Emission Flare:</strong> Floating sun-like object that drains Comfort on contact.</li>
                <li><strong>Microfiber Arrow:</strong> Fast, straight aerial projectile.</li>
                <li><strong>Landfill Drone:</strong> Flying mechanical threat.</li>
                <li><strong>Wildfire Ember:</strong> Large, fast, high-altitude spinning ember (Fire risk).</li>
            </ul>
            
            <h3>Aether Collectibles</h3>
            <ul class="info-list">
                <li><strong>Seaweed (Green Orb):</strong> Restores Comfort (Energy).</li>
                <li><strong>Wool (White Orb):</strong> Restores one Shield.</li>
                <li><strong>Coin (Yellow $):</strong> Grants 10 Aether Coins.</li>
                <li><strong>Mystery Box (?):</strong> Grants 50 Coins.</li>
            </ul>

            <h3>Quiz Power-ups</h3>
            <ul class="info-list">
                <li><strong>Invincible (‚ú®):</strong> Grants 3 seconds of obstacle immunity (Temporary).</li>
                <li><strong>Doubler (üíé):</strong> Doubles coin collection for 15 seconds (Temporary).</li>
                <li><strong>Magnet (üß≤):</strong> Attracts nearby collectibles (Permanent for this run).</li>
                <li><strong>Regen (üõ°Ô∏è):</strong> Allows your shield to restore over time (Permanent for this run).</li>
                <li><strong>Efficient (üîã):</strong> Halves energy drain rate (Permanent for this run).</li>
            </ul>
        </div>
        <button class="btn" style="max-width: 200px;" onclick="showScreen('start-screen')">Back</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden" style="justify-content: center;">
        <h1 style="font-size: 3rem; color: #E76F51;">Finished</h1>
        <p id="game-over-msg">Limit Reached</p>
        <div style="background: white; padding: 20px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); margin: 20px 0; width: 100%; max-width: 300px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="color: #888;">Distance</span>
                <span style="font-weight: bold; color: #2F6F6F;" id="final-score">0m</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color: #E9C46A; font-weight: bold;">
                <span>Best Run</span>
                <span id="game-over-best">0m</span>
            </div>
            <div style="display: flex; justify-content: space-between; border-top: 1px solid #eee; padding-top: 10px;">
                <span style="color: #888;">Earnings</span>
                <span style="font-weight: bold; color: #E9C46A;" id="coins-earned">+0 Coins</span>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn" onclick="resetGame()">Run Again</button>
            <button class="btn btn-shop" onclick="openShop()">Spend Coins</button>
            <button class="btn btn-secondary" onclick="showScreen('product-screen')">Tech Specs</button>
            <button class="btn btn-secondary" onclick="showScreen('start-screen')">Menu</button>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="custom-modal" class="screen hidden modal-overlay">
        <div class="info-panel" style="max-width: 300px; text-align: center; max-height: none;">
            <h3 id="modal-title">Shop</h3>
            <p id="modal-msg">Message</p>
            <div class="btn-group" style="flex-direction: row; justify-content: center;">
                <button id="modal-action-btn" class="btn btn-shop" style="padding: 10px 20px; font-size: 1rem;">OK</button>
                <button id="modal-close-btn" class="btn btn-secondary" style="padding: 10px 20px; font-size: 1rem;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<script>
    // --- MOUSE TRACKING ---
    let mouseX = 0;
    let mouseY = 0;
    window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    // --- AUDIO SYSTEM ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    class AudioSynth {
        constructor() {
            this.ctx = null;
            this.isMuted = false;
            this.isPlaying = false;
            this.musicPulse = 1.0; 
            this.bgmTimer = null;
        }

        init() {
            if (!this.ctx) this.ctx = new AudioContext();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }

        playTone(freq, type, duration, vol=0.1, timeOffset=0) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            const now = this.ctx.currentTime + timeOffset;
            gain.gain.setValueAtTime(vol, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.start(now);
            osc.stop(now + duration);
        }

        playSFX(type) {
            if (this.isMuted || !this.ctx) return;
            const now = this.ctx.currentTime;

            if (type === 'jump') {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } 
            else if (type === 'coin') {
                this.playTone(1200, 'sine', 0.1, 0.05);
                this.playTone(1800, 'sine', 0.2, 0.03, 0.05);
            } 
            else if (type === 'crash') {
                this.playTone(100, 'sawtooth', 0.3, 0.2);
            } 
            else if (type === 'powerup') {
                this.playTone(523.25, 'sine', 0.2, 0.1, 0);   
                this.playTone(659.25, 'sine', 0.2, 0.1, 0.1); 
                this.playTone(783.99, 'sine', 0.4, 0.1, 0.2); 
            }
            else if (type === 'mystery') {
                this.playTone(400, 'square', 0.1, 0.1, 0);
                this.playTone(600, 'square', 0.1, 0.1, 0.1);
            }
            else if (type === 'click') {
                this.playTone(800, 'triangle', 0.05, 0.05);
            }
            else if (type === 'laser') {
                this.playTone(800, 'sawtooth', 0.5, 0.2);
                this.playTone(400, 'square', 0.5, 0.2);
            }
            else if (type === 'boss_hit') {
                 this.playTone(200, 'square', 0.1, 0.3);
            }
        }

        startBGM() {
            if (this.isPlaying) return;
            if (this.isMuted || !this.ctx) return;
            this.isPlaying = true;
            this.playLoop();
        }

        stopBGM() {
            this.isPlaying = false;
            if (this.bgmTimer) clearTimeout(this.bgmTimer);
        }

        playLoop() {
            if (!this.isPlaying) return;
            let sequence = [262, 330, 392, 523, 392, 330, 294, 349];
            
            // Fixed base tempo for endless mode
            let baseTempo = 300; 
            
            let tempo = baseTempo * this.musicPulse;
            
            let noteIndex = 0;
            
            const playNext = () => {
                if (!this.isPlaying) return;
                const freq = sequence[noteIndex % sequence.length];
                this.playTone(freq / 2, 'triangle', 0.5, 0.02); 
                this.playTone(freq, 'sine', 0.4, 0.02); 
                if (noteIndex % 4 === 0) this.musicPulse = 1.2; 
                noteIndex++;
                this.bgmTimer = setTimeout(playNext, tempo);
            };
            // Clear existing timeout before setting a new one
            if (this.bgmTimer) clearTimeout(this.bgmTimer);
            playNext();
        }

        toggleMute() {
            this.isMuted = !this.isMuted;
            const btn = document.getElementById('mute-btn');
            btn.innerText = this.isMuted ? 'üîá' : 'üîä';
            if (!this.isMuted && this.isPlaying) this.playLoop();
            if (this.isMuted) this.stopBGM();
        }
    }

    const audio = new AudioSynth();
    function toggleAudio() {
        audio.init();
        audio.toggleMute();
    }
    
    let audioUnlocked = false;
    function unlockAudio() {
        if (audioUnlocked) return;
        if (audio.ctx && audio.ctx.state === 'suspended') {
            audio.ctx.resume().then(() => {
                audioUnlocked = true;
            });
        }
    }
    window.addEventListener('touchstart', unlockAudio, {once:true});
    window.addEventListener('click', unlockAudio, {once:true});

    // --- System & Config ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const PALETTE = {
        danger: '#E76F51',
        unsustainable: '#8B4513'
    };
    
    const BADGES = [
        { id: 'novice', icon: 'ü•â', desc: 'Run 1000m' },
        { id: 'runner', icon: 'ü•à', desc: 'Run 5000m' },
        { id: 'champion', icon: 'ü•á', desc: 'Reach 7000m' },
        { id: 'legend', icon: 'üëë', desc: 'Reach 20,000m' },
        { id: 'rich', icon: 'üí∞', desc: 'Collect 1000 Coins total' }
    ];

    const SKINS = [
        { id: 'default', name: 'The Prototype', desc: 'Pure black. No Aether tech. Heavy.', cost: 0, color: '#111111', secondary: '#333333', scarf: '#444444', perk: 'none' },
        { id: 'teal', name: 'Breeze Veil', desc: 'Photosynthesis: Sun damage -50%.', cost: 200, color: '#9BB1D6', secondary: '#6E85B2', scarf: '#2F6F6F', perk: 'photosynthesis' },
        { id: 'beige', name: 'Sunspire Shores', desc: 'Max Shield: 2. Start with 1.', cost: 500, color: '#E3D5CA', secondary: '#D5BDAF', scarf: '#F4F7F2', perk: 'shield_start' },
        { id: 'pink', name: 'Coral Blush', desc: 'Vitality: +30 Max Energy.', cost: 1000, color: '#F2CCC4', secondary: '#E29587', scarf: '#FFD166', perk: 'vitality' },
        { id: 'blue', name: 'Salty Haze', desc: 'Lightweight: Higher jumps.', cost: 1600, color: '#E0F4F4', secondary: '#B4D9D9', scarf: '#F1FAEE', perk: 'lightweight' },
        { id: 'green', name: 'Kelp Sprout', desc: 'Absorb: Seaweed = 2x Energy.', cost: 2400, color: '#C8D9B3', secondary: '#90A955', scarf: '#D8F3DC', perk: 'eco_boost' }
    ];

    const QUESTIONS = [
        { q: "What materials are in the Aether set?", opts: ["Cotton/Poly", "Seaweed/Merino", "Bamboo/Spandex", "Nylon/Lycra"], ans: 1 },
        { q: "Standard set includes?", opts: ["Jacket/Leggings", "T-shirt/Shorts", "Hoodie/Pants", "Two T-shirts"], ans: 1 },
        { q: "Fabric construction?", opts: ["Single knit", "Double weave", "3-layer woven", "Fleece"], ans: 2 },
        { q: "Middle layer function?", opts: ["Durability", "Antibacterial", "Air pockets", "UV Shield"], ans: 2 },
        { q: "Which layer is 'ultra-soft'?", opts: ["Inner", "Middle", "Outer", "All"], ans: 0 },
        { q: "Outer layer feature?", opts: ["Air pockets", "Waterproof", "Wave-weave", "Fleece"], ans: 2 },
        { q: "Natural UV protection source?", opts: ["Merino", "Seaweed", "Air", "Dye"], ans: 1 },
        { q: "Who is the set for?", opts: ["Men", "Women", "Kids", "Unisex"], ans: 3 }
    ];

    const DIFFICULTIES = {
        EASY: { label: "Easy", speed: 9, progression: 0.001, drain: 0.3 }, 
        MEDIUM: { label: "Medium", speed: 11, progression: 0.0015, drain: 0.6 }, 
        HARD: { label: "Hard", speed: 14, progression: 0.002, drain: 0.9 }, 
        FLOW: { label: "Flow", speed: 18, progression: 0.003, drain: 1.2 }  
    };
    const DIFF_KEYS = ['EASY', 'MEDIUM', 'HARD', 'FLOW'];
    let selectedDifficulty = 'MEDIUM';

    // --- SAVE SYSTEM ---
    let playerData = JSON.parse(localStorage.getItem('aether_player_v4')) || {
        coins: 0,
        ownedSkins: ['default'],
        equippedSkin: 'default',
        badges: []
    };
    let highScore = localStorage.getItem('aether_highscore_v4') || 0;

    function saveGame() {
        localStorage.setItem('aether_player_v4', JSON.stringify(playerData));
        updateCoinDisplays();
        renderBadges();
    }

    function updateCoinDisplays() {
        document.getElementById('menu-coins').innerText = playerData.coins;
        document.getElementById('shop-coins').innerText = playerData.coins;
        document.getElementById('menu-highscore').innerText = Math.floor(highScore);
    }
    
    function unlockBadge(id) {
        if (!playerData.badges.includes(id)) {
            playerData.badges.push(id);
            saveGame();
            spawnFloatingText(canvas.width/2, canvas.height/2, "BADGE UNLOCKED!", "#FFD700");
            audio.playSFX('powerup');
        }
    }

    function renderBadges() {
        const container = document.getElementById('badge-container');
        container.innerHTML = '';
        BADGES.forEach(b => {
            const unlocked = playerData.badges.includes(b.id);
            const div = document.createElement('div');
            div.className = `badge ${unlocked ? 'unlocked' : ''}`;
            div.innerText = b.icon;
            div.title = b.desc;
            container.appendChild(div);
        });
    }

    function getEquippedSkin() {
        return SKINS.find(s => s.id === playerData.equippedSkin) || SKINS[0];
    }

    // --- GAME CONSTANTS & VARS ---
    const GRAVITY = 0.8;          
    const BASE_JUMP_FORCE = -18.5; 
    const DIVE_FORCE = 25;
    const MAX_SPEED = 28;    
    
    let gameState = 'MENU';
    let frameId;
    let score = 0;
    let gameSpeed = 8.0; 
    let energy = 100;
    let maxEnergy = 100;
    let frameCount = 0;
    let groundY; 
    let dayTime = 0; 
    let sessionCoins = 0;
    let jumpBuffer = 0; 
    let coyoteTime = 0;
    let nextQuizThreshold = 700; 
    let buffs = { magnet: false, shieldRegen: false, efficiency: false };
    let floatingTexts = []; 
    let shakeTimer = 0;
    let invulnerableTimer = 0; 
    let coinDoublerTimer = 0; // New: Timer for coin doubling power-up
    
    let bossBattleActive = false;
    let bossDefeated = false;
    let postBossMode = false;
    let winTriggered = false;
    let boss = null;
    
    const TIME_SCALE = 1.0; 

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 1.0; this.vy = -2;
        }
        update() {
            this.y += this.vy * TIME_SCALE;
            this.life -= 0.02 * TIME_SCALE;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.font = "900 20px Montserrat";
            ctx.textAlign = "center";
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 4;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    function spawnFloatingText(x, y, text, color) {
        floatingTexts.push(new FloatingText(x, y, text, color));
    }

    // --- DYNAMIC TERRAIN SYSTEM ---
    class TerrainManager {
        constructor() {
            this.segments = [];
            this.segmentLength = 200;
            this.platforms = [];
        }

        reset() {
            this.segments = [];
            this.platforms = [];
            for(let i = 0; i < 10; i++) {
                this.addSegment(i * this.segmentLength, groundY, 'NORMAL');
            }
        }

        generateValidNextSegment(lastSeg) {
             let nextX = lastSeg.x + lastSeg.width;
             let nextY = lastSeg.y;
             let nextType = 'NORMAL';

             // Simpler ground variation
             if (Math.random() < 0.3) {
                 let maxDiff = 15 * (10 / Math.max(10, gameSpeed)); 
                 let diff = (Math.random() * maxDiff + 5); 
                 if (Math.random() > 0.5) nextY -= diff; 
                 else nextY += diff; 
             }
             // Keep ground reachable
             if (nextY > canvas.height - 50) nextY = canvas.height - 50;
             if (nextY < canvas.height - 250) nextY = canvas.height - 250;
             
             return { x: nextX, y: nextY, type: nextType };
        }

        addSegment(x, y, type) {
            if (this.segments.length > 0 && x === undefined) {
                 const last = this.segments[this.segments.length-1];
                 const next = this.generateValidNextSegment(last);
                 x = next.x; y = next.y; type = next.type;
            }

            let grad;

            if (type === 'NORMAL') {
                grad = ctx.createLinearGradient(0, y, 0, y + 400);
                grad.addColorStop(0, '#E6EBE0');
                grad.addColorStop(1, '#AAB7B8');
            } 

            this.segments.push({
                x: x, y: y, width: this.segmentLength, type: type, gradient: grad
            });

            // Platform spawning simplified for smoother experience
            if (Math.random() < 0.2) {
                let platY = y - 90 - Math.random() * 60;
                this.addPlatform(x + 50, platY);
            }
        }

        addPlatform(x, y) {
            let w = 150 + Math.random() * 50;
            this.platforms.push(new Platform(x, y, w));
        }

        update() {
            let speed = gameSpeed * TIME_SCALE;
            for (let i = this.segments.length - 1; i >= 0; i--) { this.segments[i].x -= speed; }
            for (let i = this.platforms.length - 1; i >= 0; i--) { this.platforms[i].x -= speed; }

            if (this.segments[0].x + this.segments[0].width < -100) this.segments.shift();
            this.platforms = this.platforms.filter(p => p.x + p.width > -100);

            let lastSeg = this.segments[this.segments.length - 1];
            if (lastSeg.x + lastSeg.width < canvas.width + 200) {
                const next = this.generateValidNextSegment(lastSeg);
                this.addSegment(next.x, next.y, next.type);
            }
        }

        draw(ctx) {
            for(let s of this.segments) {
                if (s.type === 'NORMAL') {
                    ctx.fillStyle = s.gradient;
                    ctx.fillRect(s.x, s.y, s.width + 2, canvas.height - s.y);
                    
                    ctx.fillStyle = '#2F6F6F'; ctx.fillRect(s.x, s.y, s.width + 2, 8); 
                    
                    // Apply subtle glow to the grass/ground surface for lighting
                    ctx.save();
                    ctx.shadowColor = '#A8C686';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = '#A8C686'; 
                    ctx.fillRect(s.x, s.y, s.width + 2, 3);
                    ctx.restore();
                }
            }
            for(let p of this.platforms) p.draw(ctx);
        }

        getSegmentAt(x) { return this.segments.find(s => x >= s.x && x < s.x + s.width); }
    }

    class Platform {
        constructor(x, y, w) { this.x = x; this.y = y; this.width = w; this.height = 20; }
        draw(ctx) {
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 4;
            ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#6E7F80';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            // Apply subtle glow to the platform surface
            ctx.save();
            ctx.shadowColor = '#A8C686';
            ctx.shadowBlur = 5;
            ctx.fillStyle = '#A8C686';
            ctx.fillRect(this.x, this.y, this.width, 6);
            ctx.restore();
        }
    }

    // Boss class removed as it is not used in endless mode

    class WeatherSystem {
        constructor() { this.type = 'CLEAR'; this.particles = []; this.timer = 0; }
        update() {
            this.timer++;
            
            // Subtle Volumetric Light Dust
            if (frameCount % 1 === 0 && Math.random() < 0.2) { 
                this.particles.push({
                    x: canvas.width, 
                    y: Math.random() * canvas.height, 
                    vx: -(0.5 + Math.random() * 0.5), 
                    vy: (Math.random() - 0.5) * 0.1, 
                    type: 'VOLUMETRIC', 
                    size: 1 + Math.random() * 1.5,
                    life: 1.0,
                    alpha: 0.05 + Math.random() * 0.05
                });
            }

            for(let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i]; 
                p.x+=p.vx * TIME_SCALE * gameSpeed * 0.1; 
                p.y+=p.vy * TIME_SCALE; 
                p.life -= 0.005; // Fade out slowly
                if(p.x < -100 || p.life <= 0) this.particles.splice(i,1);
            }
        }
        draw(ctx) {
            ctx.save();
            for(let p of this.particles) {
                 if (p.type === 'VOLUMETRIC') {
                     ctx.globalAlpha = p.alpha * p.life;
                     ctx.fillStyle = '#FFFFFF';
                     ctx.beginPath();
                     ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.globalAlpha = 1.0;
                 }
            }
            ctx.restore();
        }
    }
    
    // --- Enhanced Parallax Layers ---
    const FEATURE_TYPES = {
        MOUNTAINS: 'MOUNTAINS', 
        TREES: 'TREES',
    };

    class ParallaxLayer {
        constructor(speedFactor, yOffset, height, color, featureType) { 
            this.speedFactor=speedFactor; this.yOffset=yOffset; this.height=height; this.color=color; 
            this.features = []; this.featureType = featureType; this.generateFeatures();
        }
        
        generateFeatures() {
            this.features = [];
            let x = 0;
            const canvasWidth = window.innerWidth;
            
            while (x < canvasWidth + 2000) {
                if (this.featureType === 'MOUNTAINS') { 
                    const baseHeight = this.height * (0.8 + Math.random() * 0.4);
                    const width = 200 + Math.random() * 300;
                    const peakOffset = -baseHeight * (0.5 + Math.random() * 0.5);
                    this.features.push({x, y: this.yOffset, w: width, h: baseHeight, p: peakOffset});
                    x += width * (0.6 + Math.random() * 0.4); 
                } else if (this.featureType === 'TREES') { 
                    const size = 30 + Math.random() * 50;
                    this.features.push({x, y: this.yOffset, s: size, color: this.color});
                    x += 50 + Math.random() * 150; 
                }
            }
        }
        
        update() {
             let speed = gameSpeed * this.speedFactor; 
             for(let f of this.features) f.x-=speed;

             if(this.features.length > 0 && this.features[0].x < -500){ 
                 this.features.shift(); 
                 const lastF = this.features[this.features.length-1] || { x: -100 }; 
                 let nextX = lastF.x + (this.featureType === 'MOUNTAINS' ? 200 : 80) + Math.random() * 100;

                 if (this.featureType === 'MOUNTAINS') {
                    const baseHeight = this.height * (0.8 + Math.random() * 0.4);
                    const width = 200 + Math.random() * 300;
                    const peakOffset = -baseHeight * (0.5 + Math.random() * 0.5);
                    this.features.push({x: nextX, y: this.yOffset, w: width, h: baseHeight, p: peakOffset});
                 } else if (this.featureType === 'TREES') {
                    const size = 30 + Math.random() * 50;
                    this.features.push({x: nextX, y: this.yOffset, s: size, color: this.color});
                 } 
             }
        }

        draw(ctx) { 
            ctx.fillStyle = this.color; 
            ctx.globalAlpha = 1.0;

            for(let f of this.features){
                if (this.featureType === 'MOUNTAINS') {
                    ctx.beginPath();
                    ctx.moveTo(f.x, canvas.height - f.y);
                    ctx.lineTo(f.x + f.w/2, canvas.height - f.y + f.p);
                    ctx.lineTo(f.x + f.w, canvas.height - f.y);
                    ctx.fill();
                } else if (this.featureType === 'TREES') {
                    // Simple Pine Tree (v8.0 style)
                    ctx.fillStyle = f.color;
                    ctx.beginPath();
                    ctx.moveTo(f.x, canvas.height - f.y);
                    ctx.lineTo(f.x + f.s/2, canvas.height - f.y - f.s);
                    ctx.lineTo(f.x + f.s, canvas.height - f.y);
                    ctx.fill();
                    // Trunk
                    ctx.fillStyle = '#6D5D55';
                    ctx.fillRect(f.x + f.s/2 - 5, canvas.height - f.y, 10, 15);
                }
            }
        }
    }

    const SKY_COLORS = { 
        dawn: {top:'#FFC0CB', bot:'#FFECB3'}, 
        noon: {top:'#87CEEB', bot:'#ADD8E6'}, 
        dusk: {top:'#8A2BE2', bot:'#FFA07A'}, 
        night: {top:'#0F2027', bot:'#2C5364'} 
    };

    function lerpColor(a,b,t) { 
        let ah=parseInt(a.replace(/#/g,''),16), ar=ah>>16, ag=(ah>>8)&0xff, ab=ah&0xff, bh=parseInt(b.replace(/#/g,''),16), br=bh>>16, bg=(bh>>8)&0xff, bb=bh&0xff, rr=ar+t*(br-ar), rg=ag+t*(bg-ag), rb=ab+t*(bb-ab); 
        return '#'+((1<<24)+(Math.round(rr)<<16)+(Math.round(rg)<<8)+Math.round(rb)).toString(16).slice(1); 
    }
    
    let bgLayers = []; 
    function resize(){ 
        canvas.width=window.innerWidth; canvas.height=window.innerHeight; 
        // Set groundY so that the ground takes up 30% of the screen height (70% down)
        groundY=canvas.height-(canvas.height*0.30); 
        
        bgLayers = [
            // Distant Mountains (Slowest)
            new ParallaxLayer(0.1, 80, 200, "#C0C0C0", 'MOUNTAINS'), 
            new ParallaxLayer(0.2, 50, 150, "#A9A9A9", 'MOUNTAINS'), 
            // Mid Hills/Trees
            new ParallaxLayer(0.4, 30, 100, "#8FBC8F", 'MOUNTAINS'),
            new ParallaxLayer(0.6, 0, 150, "#2F6F6F", 'TREES'), 
        ];
    }
    window.addEventListener('resize', resize);

    class Player {
        constructor() {
            this.skin = getEquippedSkin();
            this.width = 30; this.height = 50;
            this.x = canvas.width * 0.15;
            this.y = groundY - this.height;
            this.vy = 0; this.vx = 0; 
            this.isJumping = false;
            this.shieldCount = 0; this.maxShields = 1; this.shieldRegenTimer = 0;
            this.scarfPoints = [];
            this.hasSword = false;
            this.isAttacking = false;
            this.attackCooldown = 0;
            this.forceResetToLeft = false;
            
            this.jumpMod = this.skin.perk === 'lightweight' ? 1.2 : 1.0;
            this.gravityMod = this.skin.perk === 'lightweight' ? 0.85 : 1.0;
            if (this.skin.perk === 'shield_start') { this.shieldCount = 1; this.maxShields = 2; }
            if (this.skin.perk === 'vitality') { maxEnergy = 130; energy = 130; } else { maxEnergy = 100; energy = 100; }
            for(let i=0; i<10; i++) this.scarfPoints.push({x: this.x, y: this.y});
        }
        update() {
            if (this.forceResetToLeft) {
                let targetX = canvas.width * 0.15;
                this.x += (targetX - this.x) * 0.05;
                if (Math.abs(this.x - targetX) < 5) {
                    this.x = targetX;
                    this.forceResetToLeft = false;
                    this.vx = 0; 
                }
            } else {
                this.x += this.vx * TIME_SCALE;
            }

            if (jumpBuffer > 0) { jumpBuffer--; if (!this.isJumping || coyoteTime > 0) { this.jump(); jumpBuffer = 0; } }
            
            let prevY = this.y;
            this.y += this.vy * TIME_SCALE;
            
            if (this.x < 0) this.x = 0;
            if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;

            let segment = terrain.getSegmentAt(this.x + this.width/2);
            let groundLevel = segment ? segment.y : canvas.height + 100; 
            if (coyoteTime > 0) coyoteTime--;
            let onPlatform = false;
            let playerBottom = this.y + this.height;
            let prevBottom = prevY + this.height;
            for (let p of terrain.platforms) {
                if (this.x + this.width > p.x && this.x < p.x + p.width) {
                    if (this.vy >= 0) { if (playerBottom >= p.y && prevBottom <= p.y + 15) { this.y = p.y - this.height; this.vy = 0; this.isJumping = false; onPlatform = true; coyoteTime = 10; } }
                }
            }
            if (!onPlatform) {
                if (this.y + this.height >= groundLevel) {
                    this.y = groundLevel - this.height; this.vy = 0; this.isJumping = false; coyoteTime = 10;
                } else { this.vy += (GRAVITY * this.gravityMod) * TIME_SCALE; this.isJumping = true; }
            }
            if (buffs.shieldRegen && this.shieldCount < this.maxShields) { this.shieldRegenTimer++; if (this.shieldRegenTimer > 600) { this.shieldCount++; this.shieldRegenTimer = 0; createParticles(this.x, this.y, 10, '#FFF'); audio.playSFX('powerup'); spawnFloatingText(this.x, this.y, "Shield Regened", "#FFF"); } }
            
            let prevX = this.x + 10; prevY = this.y + 10; 
            this.scarfPoints.forEach((p, index) => {
                let dx = p.x - prevX; let dy = p.y - prevY; let dist = Math.sqrt(dx*dx + dy*dy); let speed = gameSpeed * 0.8 * TIME_SCALE; 
                if (dist > 5) { p.x -= (dx * 0.3) + speed; p.y -= dy * 0.3; } p.y += Math.sin(frameCount * 0.2 + index) * 2 * TIME_SCALE; prevX = p.x; prevY = p.y;
            });
            // Removed invulnerableTimer update from here to the main gameLoop
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.isAttacking && this.attackCooldown <= 0) this.isAttacking = false;

            // Check if player is in SMOG_ZONE (SMOG_ZONE drains energy over time)
            for (const obs of obstacles) {
                if (obs.type === 'SMOG_ZONE') {
                    const smogPadding = 5;
                    if (this.x + this.width > obs.x + smogPadding && this.x < obs.x + obs.width - smogPadding &&
                        this.y + this.height > obs.y + smogPadding && this.y < obs.y + obs.height - smogPadding) {
                        energy -= 0.5 * TIME_SCALE; // Drain rate
                        createParticles(this.x + Math.random()*this.width, this.y + Math.random()*this.height, 1, '#808080');
                    }
                }
            }
        }
        jump() { if (!this.isJumping || coyoteTime > 0) { this.vy = BASE_JUMP_FORCE * this.jumpMod; this.isJumping = true; coyoteTime = 0; createParticles(this.x + this.width/2, this.y + this.height, 5, '#FFF'); audio.playSFX('jump'); } else { jumpBuffer = 6; } }
        cutJump() { if (this.vy < -5) this.vy = this.vy * 0.4; }
        dive() { if (this.isJumping) { this.vy = DIVE_FORCE; createParticles(this.x, this.y, 3, '#FFF'); } }
        
        attack() {
            // Attack logic removed for endless mode boss interaction
        }

        draw() {
            ctx.beginPath(); ctx.moveTo(this.x + 10, this.y + 10);
            for (let i = 0; i < this.scarfPoints.length; i++) { const p = this.scarfPoints[i]; let nextP = this.scarfPoints[i+1] || p; let xc = (p.x + nextP.x) / 2; let yc = (p.y + nextP.y) / 2; ctx.quadraticCurveTo(p.x, p.y, xc, yc); }
            ctx.lineWidth = 6; ctx.strokeStyle = this.skin.scarf; ctx.lineCap = 'round'; ctx.stroke();
            
            // Player Shield Glow
            if (this.shieldCount > 0) { 
                ctx.save();
                ctx.shadowColor = "rgba(255, 255, 255, 1)";
                ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI*2); ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; ctx.fill(); 
                ctx.shadowBlur = 0;
                ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineWidth = 2; ctx.stroke(); 
                ctx.restore();
            }
            
            ctx.fillStyle = this.skin.secondary;
            if (this.isJumping) { ctx.fillRect(this.x + 5, this.y + 40, 8, 15); ctx.fillRect(this.x + 20, this.y + 35, 8, 20); } 
            else { let stride = Math.sin(frameCount * 0.3) * 10; ctx.beginPath(); ctx.moveTo(this.x + 15, this.y + 40); ctx.lineTo(this.x + 5 - stride, this.y + 50 + stride); ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x + 15, this.y + 40); ctx.lineTo(this.x + 25 + stride, this.y + 50 - stride); ctx.strokeStyle = this.skin.secondary; ctx.lineWidth = 8; ctx.stroke(); }
            ctx.fillStyle = this.skin.color; ctx.beginPath(); ctx.roundRect(this.x, this.y + 10, this.width, 35, 5); ctx.fill();
            if (invulnerableTimer > 0) { ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random()})`; ctx.lineWidth = 2; ctx.strokeRect(this.x - 2, this.y + 8, this.width + 4, 39); }
            ctx.fillStyle = this.skin.secondary; ctx.beginPath(); ctx.arc(this.x + 18, this.y + 5, 12, 0, Math.PI*2); ctx.fill();
            
            // Boss Sword elements removed
        }
    }

    class Obstacle {
        constructor(type, xOverride, yOverride) {
            this.type = type; this.speedX = 0; this.damage = 15;
            let spawnY = terrain.segments[terrain.segments.length-1].y;

            // --- OBSTACLE DEFINITIONS ---
            if (type === 'MICROFIBER_ARROW') { // Projectile
                 this.width = 60; this.height = 30; this.y = Math.random() > 0.5 ? spawnY - 130 : spawnY - 40; this.speedX = 6 + Math.random() * 3; this.damage = 25; 
            } 
            else if (type === 'ARROW') { // Keeping ARROW for compatibility but it's another microfiber
                this.width = 40; this.height = 10; this.y = spawnY - 60 - Math.random() * 60; this.speedX = 15; this.damage = 20; 
            }
            else if (type === 'CO2_FLARE') { // Floating Drain
                this.width = 40; this.height = 40; this.y = spawnY - 80 - (Math.random() * 100); this.damage = 30; 
            } 
            else if (type === 'LANDFILL_DRONE') { // Flying Threat
                this.width = 25; this.height = 15; this.y = spawnY - 150 - (Math.random() * 80); this.speedX = 10 + Math.random() * 5; this.damage = 40; 
            } 
            // Ground Threat: PLASTIC_BALE
            else if (type === 'PLASTIC_BALE') {
                 this.width = 60; this.height = 80; this.y = spawnY - this.height - 5; this.damage = 20;
            }
            // PROJECTILE REVERT: PLASTIC_BOTTLE (Ocean Waste)
            else if (type === 'PLASTIC_BOTTLE') {
                 this.width = 15; this.height = 40; this.y = spawnY - 50; this.speedX = 18 + Math.random() * 5; this.damage = 15;
                 this.initialY = this.y;
                 this.waveOffset = Math.random() * Math.PI * 2;
            }
            // DRAIN ZONE REVERT: SMOG_ZONE (Air Pollution)
            else if (type === 'SMOG_ZONE') {
                 this.width = 150; this.height = 80; this.y = spawnY - 150 - (Math.random() * 100); this.damage = 0; // No impact damage, only drain
                 this.isStatic = true;
            }
            // NEW AERIAL THREAT: WILDFIRE EMBER
            else if (type === 'WILDFIRE_EMBER') { 
                 this.width = 80; this.height = 30; // Increased size (BIGGER)
                 
                 // Spawn slightly higher up, between 35% and 55% of screen height
                 const spawnCenter = canvas.height * 0.45; // Shifted center slightly higher (was 0.5)
                 const variance = canvas.height * 0.2; 
                 this.y = yOverride || (spawnCenter + (Math.random() - 0.5) * variance); 

                 // REDUCED SPEED: from 15 + Math.random() * 5 to 12 + Math.random() * 3
                 this.speedX = 12 + Math.random() * 3; 
                 this.damage = 35;
                 this.angle = Math.random() * Math.PI * 2; // Initial spinning angle
            }
            else { this.width = 40; this.height = 50; this.y = spawnY - this.height - 5; this.damage = 15; } // STIFF_NYLON_TAG (Ground Default)
            
            if (!xOverride) this.x = canvas.width + Math.random() * 100;
            
            this.isMoving = Math.random() < 0.4; this.angle = 0;
            this.initialY = this.y;
            this.points = []; let numPoints = 6; for(let i=0; i<numPoints; i++) { let angle = (i/numPoints) * Math.PI * 2; let r = 20 + Math.random() * 10; this.points.push({x: Math.cos(angle) * r, y: Math.sin(angle) * r}); }
        }
        update() {
            this.x -= (gameSpeed + this.speedX) * TIME_SCALE;
            
            // PROJECTILE movement
            if (['MICROFIBER_ARROW', 'ARROW', 'PLASTIC_BOTTLE'].includes(this.type)) { 
                if (this.vy) this.y += this.vy * TIME_SCALE; 
                this.y += Math.sin(this.x * 0.05) * 2 * TIME_SCALE;
            }
            
            // PLASTIC_BOTTLE erratic movement
            if (this.type === 'PLASTIC_BOTTLE') {
                this.y = this.initialY + Math.sin(frameCount * 0.1 + this.waveOffset) * 20; 
                this.angle += 0.2 * TIME_SCALE;
            }
            else if (this.type === 'CO2_FLARE') this.y = this.initialY + Math.sin(frameCount * 0.05) * 50;
            else if (this.type === 'SMOG_ZONE') { this.y = this.initialY + Math.sin(frameCount * 0.03) * 10; } // Slow float for smog
            else if (this.type === 'STIFF_NYLON_TAG' && this.isMoving) { this.x -= 2.5 * TIME_SCALE; this.angle -= 0.15 * TIME_SCALE; }
            // NEW AERIAL THREAT: WILDFIRE EMBER
            else if (this.type === 'WILDFIRE_EMBER') {
                 this.angle += 0.3 * TIME_SCALE;
            }
            
            for (let p of terrain.platforms) { if (this.x < p.x + p.width - 5 && this.x + this.width > p.x + 5 && this.y < p.y + p.height - 5 && this.y + this.height > p.y + 5) this.markedForDeletion = true; }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);

            if (this.type === 'MICROFIBER_ARROW' || this.type === 'ARROW') { 
                ctx.fillStyle = '#00AAAA'; // Teal synthetic fiber
                ctx.shadowColor = '#00FFFF'; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.moveTo(this.width/2, -this.height/2); ctx.lineTo(-this.width/2, 0); ctx.lineTo(this.width/2, this.height/2); ctx.lineTo(this.width/2 - 15, 0); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = '#009999'; ctx.lineWidth = 3; ctx.stroke();
            } else if (this.type === 'CO2_FLARE') { 
                 ctx.fillStyle = '#FF6347'; // Tomato red for heat/emissions
                 ctx.shadowColor = '#FF4500'; ctx.shadowBlur = 25; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill(); 
            } else if (this.type === 'LANDFILL_DRONE') { 
                ctx.fillStyle = '#6D6D6D'; // Grey drone
                ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.moveTo(-this.width/2, 0); ctx.lineTo(this.width/2, -this.height/2); ctx.lineTo(this.width/2, this.height/2); ctx.closePath(); ctx.fill();
            } else if (this.type === 'PLASTIC_BALE') {
                 ctx.shadowColor = PALETTE.unsustainable; ctx.shadowBlur = 10;
                 ctx.fillStyle = PALETTE.unsustainable; // Brown/Earth tone for landfill
                 ctx.beginPath(); 
                 ctx.roundRect(-this.width/2, -this.height/2, this.width, this.height, 5); 
                 ctx.fill();
                 ctx.strokeStyle = '#D2B48C'; ctx.lineWidth = 2; 
                 // Draw vertical lines to simulate bales/straps
                 ctx.beginPath(); 
                 ctx.moveTo(-10, -40); ctx.lineTo(-10, 40);
                 ctx.moveTo(10, -40); ctx.lineTo(10, 40);
                 ctx.stroke();
            } 
            // REVERTED: PLASTIC_BOTTLE (Ocean Waste)
            else if (this.type === 'PLASTIC_BOTTLE') {
                ctx.rotate(this.angle);
                ctx.fillStyle = 'rgba(100, 180, 255, 0.7)'; // Transparent blue plastic
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 1;
                ctx.roundRect(-this.width/2, -this.height/2, this.width, this.height, 5); 
                ctx.fill(); ctx.stroke();
                // Bottle cap
                ctx.fillStyle = '#FF4500'; 
                ctx.fillRect(-this.width/2, -this.height/2, this.width, 5);
                ctx.shadowColor = 'transparent'; 
            } 
            // REVERTED: SMOG_ZONE (Air Pollution)
            else if (this.type === 'SMOG_ZONE') {
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = 'rgba(128, 128, 128, 0.5)'; // Grey/Black smog
                ctx.shadowColor = '#333333'; ctx.shadowBlur = 30;
                ctx.beginPath();
                // Blobs to simulate cloud
                ctx.arc(-50, -10, 50, 0, Math.PI * 2);
                ctx.arc(0, 20, 60, 0, Math.PI * 2);
                ctx.arc(50, -15, 45, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            } 
            // NEW AERIAL THREAT: WILDFIRE EMBER (Made BIGGER with new fiery draw)
            else if (this.type === 'WILDFIRE_EMBER') {
                 ctx.rotate(this.angle);
                 ctx.shadowColor = '#FF8C00'; 
                 ctx.shadowBlur = 20;
                 ctx.globalAlpha = 0.8;

                 // Draw the fiery core (3 overlapping circles/blobs)
                 ctx.fillStyle = '#FF4500'; // Deep Orange/Red
                 ctx.beginPath();
                 ctx.arc(-this.width * 0.2, 0, this.width * 0.3, 0, Math.PI * 2);
                 ctx.fill();

                 ctx.fillStyle = '#FFA500'; // Brighter Orange
                 ctx.beginPath();
                 ctx.arc(this.width * 0.2, 0, this.width * 0.25, 0, Math.PI * 2);
                 ctx.fill();

                 ctx.fillStyle = '#FFD700'; // Yellowish Core
                 ctx.beginPath();
                 ctx.arc(0, 0, this.width * 0.2, 0, Math.PI * 2);
                 ctx.fill();
            }
            else {
                // STIFF_NYLON_TAG (Ground Default)
                ctx.rotate(this.angle); 
                ctx.fillStyle = '#E0E0E0'; // Light grey/white for tag/stiffness
                ctx.shadowColor = '#555555'; ctx.shadowBlur = 10;
                ctx.beginPath(); 
                ctx.roundRect(-this.width/2, -this.height/2, this.width, this.height, 5); 
                ctx.fill(); 
                ctx.strokeStyle = "#555555"; 
                ctx.lineWidth = 4; 
                ctx.stroke();
            }
            ctx.restore();
        }
    }

    class Collectible {
        // Constructor now accepts a target Y position
        constructor(yTarget) {
            this.width = 30; this.height = 30; 
            this.x = canvas.width; 
            this.y = yTarget || (Math.random() * (canvas.height * 0.6) + 50); // Use targetY if provided
            
            const r = Math.random();
            if (r < 0.4) this.type = 'SEAWEED'; else if (r < 0.6) this.type = 'WOOL'; else if (r < 0.9) this.type = 'COIN'; else this.type = 'MYSTERY';
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 15;
            
            if (this.type === 'SEAWEED') { 
                ctx.shadowColor = '#00FF00';
                ctx.fillStyle = '#2A9D8F'; ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 10, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x+15, this.y+5); ctx.quadraticCurveTo(this.x+5, this.y+15, this.x+15, this.y+25); ctx.quadraticCurveTo(this.x+25, this.y+15, this.x+15, this.y+5); ctx.stroke(); 
            } 
            else if (this.type === 'WOOL') { 
                ctx.shadowColor = '#FFFFFF';
                ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 12, 0, Math.PI*2); ctx.fill(); 
            } 
            else if (this.type === 'COIN') { 
                ctx.shadowColor = '#FFD700';
                ctx.fillStyle = '#FFD700'; ctx.strokeStyle = '#DAA520'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#DAA520'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('$', this.x+15, this.y+19); 
            } 
            else if (this.type === 'MYSTERY') { 
                ctx.shadowColor = '#9932CC';
                ctx.fillStyle = '#9932CC'; ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(this.x, this.y, 30, 30); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#FFF'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText('?', this.x+15, this.y+21); 
            }
            ctx.restore();
        }
        update() {
            this.x -= gameSpeed * TIME_SCALE; this.y += Math.sin(frameCount * 0.1) * 0.5 * TIME_SCALE;
            if (buffs.magnet) { let dx = player.x - this.x; let dy = player.y - this.y; let dist = Math.sqrt(dx*dx + dy*dy); if (dist < 250) { this.x += dx * 0.05 * TIME_SCALE; this.y += dy * 0.05 * TIME_SCALE; } }
        }
    }

    class Particle {
        constructor(x, y, size, color) { this.x = x; this.y = y; this.size = size; this.color = color; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.life = 1.0; }
        update() { this.x += this.vx * TIME_SCALE; this.y += this.vy * TIME_SCALE; this.life -= 0.05 * TIME_SCALE; }
        draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
    }

    class Cloud {
        constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * (canvas.height * 0.5); this.speed = Math.random() * 0.5 + 0.1; this.width = 60 + Math.random() * 60; this.alpha = 0.3 + Math.random() * 0.4; }
        update() { this.x -= (this.speed + (gameSpeed * 0.05)) * TIME_SCALE; if (this.x + this.width < 0) this.x = canvas.width + 50; }
        draw() { ctx.fillStyle = `rgba(255,255,255,${this.alpha})`; ctx.beginPath(); ctx.roundRect(this.x, this.y, this.width, 30, 20); ctx.fill(); }
    }

    // --- Logic ---
    var player, terrain, weather, obstacles, collectibles, particles, clouds;

    function init() {
        resize();
        audio.init(); 
        
        terrain = new TerrainManager();
        terrain.reset();
        weather = new WeatherSystem();

        player = new Player();
        obstacles = [];
        collectibles = [];
        particles = [];
        floatingTexts = [];
        score = 0;
        sessionCoins = 0;
        shakeTimer = 0;
        invulnerableTimer = 0; // Reset timer on init
        coinDoublerTimer = 0; // Reset new timer
        
        bossBattleActive = false;
        bossDefeated = false;
        postBossMode = false;
        winTriggered = false;
        boss = null;
        
        gameSpeed = DIFFICULTIES[selectedDifficulty].speed;
        
        frameCount = 0;
        dayTime = 0.3; 
        nextQuizThreshold = 700; 
        buffs = { magnet: false, shieldRegen: false, efficiency: false };
        
        clouds = [];
        for(let i=0; i<8; i++) clouds.push(new Cloud());
        
        document.getElementById('hud-highscore').innerText = Math.floor(highScore);
        document.getElementById('boss-hud').style.display = 'none';
        document.getElementById('attack-btn').style.display = 'none';
        
        audio.startBGM();
    }
    
    function createParticles(x, y, count, color) {
        if (window.innerWidth < 768) count = Math.ceil(count / 2);
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, Math.random()*4+2, color));
    }

    function flashScreen() {
        const overlay = document.getElementById('damage-overlay');
        overlay.style.opacity = '1';
        setTimeout(() => { overlay.style.opacity = '0'; }, 100);
        shakeTimer = 10; 
    }
    
    // --- DIFFICULTY SYSTEM ---
    function cycleDifficulty() {
        let idx = DIFF_KEYS.indexOf(selectedDifficulty);
        idx = (idx + 1) % DIFF_KEYS.length;
        selectedDifficulty = DIFF_KEYS[idx];
        
        const btn = document.getElementById('diff-btn');
        btn.innerText = "Difficulty: " + DIFFICULTIES[selectedDifficulty].label;
        audio.playSFX('click');
    }

    // --- QUIZ LOGIC (Unchanged) ---
    function triggerQuiz() {
        gameState = 'QUIZ';
        const qData = QUESTIONS[Math.floor(Math.random() * QUESTIONS.length)];
        
        document.getElementById('quiz-question').innerText = qData.q;
        const optsContainer = document.getElementById('quiz-options');
        optsContainer.innerHTML = '';
        
        qData.opts.forEach((opt, idx) => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-option';
            btn.innerText = opt;
            btn.onclick = () => handleQuizAnswer(idx === qData.ans);
            optsContainer.appendChild(btn);
        });

        showScreen('quiz-screen');
    }

    function handleQuizAnswer(isCorrect) {
        if (isCorrect) {
            sessionCoins += 50;
            audio.playSFX('powerup');
            showScreen('reward-screen');
        } else {
            gameState = 'PLAYING';
            showScreen('none');
            gameLoop();
        }
    }

    function applyBuff(type) {
        audio.playSFX('powerup');
        
        // Permanent Buffs (Magnet, Regen, Efficiency)
        if (type === 'MAGNET') buffs.magnet = true;
        if (type === 'SHIELD_REGEN') {
            buffs.shieldRegen = true;
            if (player.shieldCount < player.maxShields) {
                player.shieldCount++;
                createParticles(player.x, player.y, 10, '#FFF');
            }
        }
        if (type === 'EFFICIENCY') buffs.efficiency = true;
        
        // Temporary Buffs
        if (type === 'INVULNERABILITY') invulnerableTimer = 180; // 3 seconds at 60 FPS
        if (type === 'COIN_DOUBLER') coinDoublerTimer = 900; // 15 seconds at 60 FPS
        
        gameState = 'PLAYING';
        showScreen('none');
        gameLoop();
    }

    function spawnLogic() {
        if (bossBattleActive) return; 

        // Define which obstacles are available based on score
        
        // T1: Start (Ground Default, CO2, Microfiber Arrow)
        let availableObstacles = ['STIFF_NYLON_TAG', 'CO2_FLARE', 'MICROFIBER_ARROW']; 
        
        // T2: 1000m (Landfill Bale, generic Arrow, Landfill Drone, NEW: WILDFIRE_EMBER)
        if (score >= 1000) {
            availableObstacles.push('PLASTIC_BALE', 'ARROW', 'LANDFILL_DRONE', 'WILDFIRE_EMBER'); 
        }
        
        // T3: 3000m (PLASTIC_BOTTLE (revert), SMOG_ZONE (revert))
        if (score >= 3000) {
            availableObstacles.push('PLASTIC_BOTTLE', 'SMOG_ZONE'); 
        }

        // Base spawn rate depends on game speed
        let spawnThreshold = 80 - (gameSpeed * 2); 
        
        // Difficulty Tier 4: Once all obstacle types are available (after 3000m)
        if (availableObstacles.length >= 8) {
             // Capping the overall spawn rate to prevent excessive difficulty spike
             spawnThreshold = 30 - (gameSpeed * 0.5); 
        }
        
        // Ensure a minimum gap of 20 frames between major spawns
        if (spawnThreshold < 20) spawnThreshold = 20; 

        if (frameCount % Math.floor(spawnThreshold) === 0) {
            const index = Math.floor(Math.random() * availableObstacles.length);
            const type = availableObstacles[index];
            
            obstacles.push(new Obstacle(type));
        }
        
        if (frameCount % 150 === 0) {
            if (Math.random() > 0.3) {
                // Determine reachable Y target
                let targetY;
                // Find a segment just off screen to determine the ground level
                let segment = terrain.segments.find(s => s.x > canvas.width - 200); 
                
                if (segment) {
                    let groundLevel = segment.y;
                    // Spawn between 30 and 130px above ground, ensuring reachability
                    targetY = Math.max(50, groundLevel - (Math.random() * 100 + 30)); 

                    // Check for platform in the near future (within 500px) and potentially place collectible there
                    let platform = terrain.platforms.find(p => p.x > canvas.width && p.x < canvas.width + 500);
                    if (platform && Math.random() > 0.5) {
                        // Spawn slightly above the platform, ensure not too high
                        targetY = Math.min(platform.y - 40, groundLevel - 150); 
                    }
                } else {
                    // Fallback 
                    targetY = canvas.height * 0.5;
                }
                
                collectibles.push(new Collectible(targetY));
            }
        }
    }

    function drawEnvironment() {
        ctx.shadowBlur = 0; // Reset blur for non-glowing elements
        ctx.shadowColor = 'transparent';
        
        // Simple day/night cycle for aesthetics
        dayTime = (dayTime + 0.0005 * TIME_SCALE) % 1.0; 
        let topC, botC;
        if (dayTime < 0.25) { let t = dayTime / 0.25; topC = lerpColor(SKY_COLORS.dawn.top, SKY_COLORS.noon.top, t); botC = lerpColor(SKY_COLORS.dawn.bot, SKY_COLORS.noon.bot, t); } 
        else if (dayTime < 0.5) { let t = (dayTime - 0.25) / 0.25; topC = lerpColor(SKY_COLORS.noon.top, SKY_COLORS.dusk.top, t); botC = lerpColor(SKY_COLORS.noon.bot, SKY_COLORS.dusk.bot, t); } 
        else if (dayTime < 0.75) { let t = (dayTime - 0.5) / 0.25; topC = lerpColor(SKY_COLORS.dusk.top, SKY_COLORS.night.top, t); botC = lerpColor(SKY_COLORS.dusk.bot, SKY_COLORS.night.bot, t); } 
        else { let t = (dayTime - 0.75) / 0.25; topC = lerpColor(SKY_COLORS.night.top, SKY_COLORS.dawn.top, t); botC = lerpColor(SKY_COLORS.night.bot, SKY_COLORS.dawn.bot, t); }
        let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height); 
        skyGradient.addColorStop(0, topC); 
        skyGradient.addColorStop(1, botC); 
        ctx.fillStyle = skyGradient; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (shakeTimer > 0) { ctx.save(); let dx = (Math.random() - 0.5) * 10; let dy = (Math.random() - 0.5) * 10; ctx.translate(dx, dy); shakeTimer--; }

        bgLayers.forEach(layer => { layer.update(); layer.draw(ctx); });
        clouds.forEach(c => { c.update(); c.draw(); });

        terrain.update();
        terrain.draw(ctx);
        
        // DRAW VOLUMETRIC/WEATHER EFFECTS *BEFORE* PLAYER/FOREGROUND
        weather.update();
        weather.draw(ctx); 

        // Apply Vignette / Atmospheric Fog (simulated shader)
        ctx.save();
        let vignette = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width);
        vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        // IMPORTANT: Reset global shadow properties
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        if (shakeTimer >= 0) ctx.restore();
    }

    function checkCollisions() {
        const padding = 10; 
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            if (obs.x + obs.width < -100) { obstacles.splice(i, 1); continue; }

            let hitX = player.x + padding < obs.x + obs.width - padding && player.x + player.width - padding > obs.x + padding;
            let hitY = player.y + padding < obs.y + obs.height - padding && player.y + player.height - padding > obs.y + padding;

            if (hitX && hitY) {
                // SMOG_ZONE does not grant invulnerability, only drain (handled in Player.update)
                if (obs.type === 'SMOG_ZONE') continue; 
                // Check general invulnerability
                if (invulnerableTimer > 0) {
                    obstacles.splice(i, 1);
                    createParticles(player.x, player.y, 8, '#FFD700');
                    spawnFloatingText(player.x, player.y - 30, "Absorbed", "#FFD700");
                    continue;
                }

                if (player.shieldCount > 0) {
                    player.shieldCount--; obstacles.splice(i, 1); createParticles(player.x, player.y, 10, player.skin.color); flashScreen(); audio.playSFX('crash'); spawnFloatingText(player.x, player.y - 30, "Shield Lost", "#FFF");
                } else {
                    let dmg = obs.damage;
                    flashScreen(); audio.playSFX('crash'); energy -= dmg; createParticles(player.x, player.y, 8, PALETTE.danger); obstacles.splice(i, 1); spawnFloatingText(player.x, player.y - 30, "-" + Math.floor(dmg) + " Energy", "#E76F51");
                    if (energy <= 0) endGame('Impact!'); 
                }
            }
        }
        // Collectibles
        const itemPadding = 15;
        for (let i = collectibles.length - 1; i >= 0; i--) {
            let c = collectibles[i];
            let hit = player.x < c.x + c.width + itemPadding && player.x + player.width > c.x - itemPadding && player.y < c.y + c.height + itemPadding && player.y + player.height > c.y - itemPadding;
            if (hit) {
                collectibles.splice(i, 1);
                if (c.type === 'SEAWEED') { audio.playSFX('coin'); let amount = 20; if (player.skin.perk === 'eco_boost') amount = 40; energy = Math.min(maxEnergy, energy + amount); createParticles(c.x, c.y, 5, '#2A9D8F'); spawnFloatingText(c.x, c.y, "+" + amount + " Energy", "#2A9D8F"); } 
                else if (c.type === 'WOOL') { audio.playSFX('coin'); if (player.shieldCount < player.maxShields) { player.shieldCount++; createParticles(c.x, c.y, 5, '#FFF'); spawnFloatingText(c.x, c.y, "Shield Up", "#FFF"); } } 
                else if (c.type === 'COIN') { audio.playSFX('coin'); let amount = 10; if (coinDoublerTimer > 0) amount *= 2; sessionCoins += amount; createParticles(c.x, c.y, 5, '#FFD700'); spawnFloatingText(c.x, c.y, "+" + amount + " Coins", "#FFD700"); } 
                else if (c.type === 'MYSTERY') { audio.playSFX('mystery'); let amount = 50; if (coinDoublerTimer > 0) amount *= 2; sessionCoins+=amount; spawnFloatingText(player.x, player.y, "+" + amount + " Coins", "#FFD700"); }
            }
        }
    }

    function gameLoop() {
        if (gameState !== 'PLAYING') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        frameCount++;
        
        // Update temporary timers
        if (invulnerableTimer > 0) invulnerableTimer -= TIME_SCALE;
        if (coinDoublerTimer > 0) coinDoublerTimer -= TIME_SCALE;
        
        let diffSettings = DIFFICULTIES[selectedDifficulty];
        
        // Progression Logic
        if (gameSpeed < MAX_SPEED) {
            gameSpeed = Math.min(MAX_SPEED, gameSpeed + diffSettings.progression * TIME_SCALE);
            score += (gameSpeed * TIME_SCALE * 0.05);
        }
        
        // Check milestone achievement
        if (score >= 7000 && !playerData.badges.includes('champion')) unlockBadge('champion');
        if (score > 20000 && !winTriggered) {
            winTriggered = true;
            unlockBadge('legend');
            gameState = 'WIN';
            showScreen('win-screen');
            return;
        }

        if (score >= 1000) unlockBadge('novice');
        if (score >= 5000) unlockBadge('runner');
        
        // Quiz Trigger Logic
        if (score >= nextQuizThreshold) {
            nextQuizThreshold += 700; 
            triggerQuiz();
            return; 
        }

        if (frameCount % 60 === 0) {
            let drain = diffSettings.drain * TIME_SCALE;
            if (buffs.efficiency) drain *= 0.5;
            energy -= drain;
        }
        if (energy <= 0) { endGame('Out of Energy'); return; }

        player.update();
        spawnLogic();

        drawEnvironment();

        // Draw gameplay elements
        if (gameState !== 'QUIZ') {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                if (obstacles[i].markedForDeletion) { obstacles.splice(i, 1); } 
                else if (obstacles[i].x + obstacles[i].width > -100) { obstacles[i].draw(); } 
                else { obstacles.splice(i, 1); }
            }
            for (let i = collectibles.length - 1; i >= 0; i--) { collectibles[i].update(); if (collectibles[i].x + collectibles[i].width > -100) collectibles[i].draw(); else collectibles.splice(i, 1); }
            for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if (particles[i].life > 0) particles[i].draw(); else particles.splice(i, 1); }
            for (let i = floatingTexts.length - 1; i >= 0; i--) { floatingTexts[i].update(); if (floatingTexts[i].life > 0) floatingTexts[i].draw(ctx); else floatingTexts.splice(i, 1); }

            player.draw();
            checkCollisions();
        }
        
        // Update HUD
        document.getElementById('score').innerText = Math.floor(score);
        document.getElementById('hud-highscore').innerText = Math.floor(highScore); 
        const bar = document.getElementById('energy-fill');
        bar.style.width = Math.max(0, (energy / maxEnergy) * 100) + '%';
        if (energy < 30) bar.style.background = PALETTE.danger; else bar.style.background = `linear-gradient(90deg, #2A9D8F, #2F6F6F)`;

        // Attack button is hidden in endless mode
        document.getElementById('attack-btn').style.display = 'none';

        frameId = requestAnimationFrame(gameLoop);
    }

    // --- State Management ---
    function startGame() { 
        showScreen('none'); 
        init(); 
        gameState = 'PLAYING'; 
        gameLoop(); 
        audio.playSFX('powerup'); 
    }
    function endGame(reason) {
        gameState = 'GAMEOVER'; cancelAnimationFrame(frameId); audio.stopBGM(); audio.playSFX('crash');
        let earned = Math.floor(score / 10) + sessionCoins; playerData.coins += earned;
        if (score > highScore) { highScore = score; localStorage.setItem('aether_highscore_v4', highScore); }
        if (playerData.coins >= 1000) unlockBadge('rich');
        saveGame();
        document.getElementById('final-score').innerText = Math.floor(score) + "m"; document.getElementById('game-over-best').innerText = Math.floor(highScore) + "m"; document.getElementById('coins-earned').innerText = "+" + earned + " Coins"; document.getElementById('game-over-msg').innerText = reason; showScreen('game-over-screen');
    }
    function continueEndless() { gameState = 'PLAYING'; showScreen('none'); gameLoop(); }
    function resetGame() { startGame(); }
    function openShop() { showScreen('shop-screen'); renderShop(); }
    
    function playerAttack() {
        // Attack logic is disabled in endless mode
    }
    
    function renderShop() {
        const container = document.getElementById('shop-container'); container.innerHTML = '';
        SKINS.forEach(skin => {
            const owned = playerData.ownedSkins.includes(skin.id); const equipped = playerData.equippedSkin === skin.id; const div = document.createElement('div'); div.className = `shop-item ${equipped ? 'active' : ''}`; div.onclick = () => handleShopClick(skin.id);
            let btnLabel = owned ? (equipped ? 'EQUIPPED' : 'EQUIP') : `${skin.cost} ü™ô`; let btnClass = owned ? 'owned-tag' : 'skin-price'; if (equipped) btnClass += ' active-tag'; 
            div.innerHTML = `<div class="skin-preview" style="background:${skin.color}; border-color:${skin.secondary}"></div><div class="skin-name">${skin.name}</div><div class="skin-perk">${skin.desc}</div><div class="${btnClass}">${btnLabel}</div>`; container.appendChild(div);
        });
    }
    function showModal(msg, onConfirm) { const modal = document.getElementById('custom-modal'); const msgEl = document.getElementById('modal-msg'); const actionBtn = document.getElementById('modal-action-btn'); const closeBtn = document.getElementById('modal-close-btn'); msgEl.innerText = msg; modal.classList.remove('hidden'); if (onConfirm) { actionBtn.innerText = "Confirm"; closeBtn.style.display = "inline-block"; actionBtn.onclick = () => { onConfirm(); modal.classList.add('hidden'); }; } else { actionBtn.innerText = "OK"; closeBtn.style.display = "none"; actionBtn.onclick = () => { modal.classList.add('hidden'); }; } closeBtn.onclick = () => modal.classList.add('hidden'); }
    function handleShopClick(id) { const skin = SKINS.find(s => s.id === id); const owned = playerData.ownedSkins.includes(id); if (owned) { playerData.equippedSkin = id; saveGame(); renderShop(); audio.playSFX('click'); } else { if (playerData.coins >= skin.cost) { showModal(`Buy ${skin.name} for ${skin.cost} Coins?`, () => { playerData.coins -= skin.cost; playerData.ownedSkins.push(id); playerData.equippedSkin = id; saveGame(); renderShop(); audio.playSFX('powerup'); }); } else { showModal("Not enough coins! Keep running!"); audio.playSFX('click'); } } }
    function showScreen(id) { document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden')); if(id !== 'none') document.getElementById(id).classList.remove('hidden'); }

    window.addEventListener('keydown', (e) => {
        if (e.code === 'ArrowLeft' || e.code === 'KeyA') player.vx = 0;
        if (e.code === 'ArrowRight' || e.code === 'KeyD') player.vx = 0;
        if (e.code === 'KeyF') player.attack();

        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { 
            e.preventDefault(); 
            if (gameState === 'PLAYING') { player.jump(); } 
        }
        if (e.code === 'ArrowDown' || e.code === 'KeyS') { 
            e.preventDefault(); 
            if (gameState === 'PLAYING') { player.dive(); } 
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'KeyA' || e.code === 'KeyD') player.vx = 0;
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { 
            if (gameState === 'PLAYING') player.cutJump(); 
        }
    });
    
    // Touch controls
    window.addEventListener('touchstart', (e) => {
        // Crucial check: If the touch target is part of a UI button, abort game controls.
        if (e.target.closest('button') || e.target.id === 'attack-btn') {
            return;
        }

        if (gameState !== 'PLAYING') return;
        e.preventDefault(); 
        window.touchStartY = e.changedTouches[0].clientY;
        
    }, {passive: false});
    
    window.addEventListener('touchend', (e) => {
        // Crucial check: If the touch target is part of a UI button, abort game controls.
        if (e.target.closest('button') || e.target.id === 'attack-btn') {
            return;
        }

        e.preventDefault();
        
        if (gameState !== 'PLAYING') return;
        
        let deltaY = e.changedTouches[0].clientY - window.touchStartY;
        
        // Handle jump cut/coyote time logic regardless of swipe
        if (gameState === 'PLAYING') player.cutJump();
        
        if (deltaY > 30) { 
            // Downward swipe (Dive)
            if (gameState === 'PLAYING') player.dive(); 
        } 
        else { 
            // Tap or upward swipe (Jump)
            if (gameState === 'PLAYING') player.jump(); 
        }
    });
    
    window.addEventListener('mousedown', (e) => { 
        if(e.target.tagName !== 'BUTTON' && e.target.id !== 'attack-btn' && gameState === 'PLAYING') {
            player.attack(); 
        }
    });
    window.addEventListener('mouseup', (e) => { if(gameState === 'PLAYING') player.cutJump(); });

    resize();
    updateCoinDisplays();
    renderBadges();
</script>
</body>
</html>
