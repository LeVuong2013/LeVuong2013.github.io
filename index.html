<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aether: The Flow State</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #F4F7F2;
            font-family: 'Montserrat', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            cursor: crosshair;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px 30px;
            color: #2F6F6F;
            text-shadow: 0 2px 4px rgba(255,255,255,0.8);
        }

        .score-block {
            text-align: left;
        }

        .score-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .score-val {
            font-size: 32px;
            font-weight: 900;
            letter-spacing: 1px;
        }

        .highscore-in-game {
            font-size: 0.9rem;
            color: #E9C46A;
            font-weight: 700;
            margin-top: 2px;
        }

        .currency-display {
            font-size: 16px;
            font-weight: 700;
            color: #E9C46A;
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .energy-wrapper {
            text-align: right;
        }

        .energy-bar-container {
            width: 200px;
            height: 12px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #2F6F6F;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #energy-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #2A9D8F, #2F6F6F);
            transition: width 0.1s linear;
        }

        /* Boss HUD */
        #boss-hud {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            display: none; 
            flex-direction: column;
            align-items: center;
        }
        .boss-name {
            color: #8B0000;
            font-weight: 900;
            font-size: 1.5rem;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,0,0,0.5);
            margin-bottom: 5px;
        }
        .boss-hp-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #8B0000;
            border-radius: 10px;
            overflow: hidden;
        }
        #boss-hp-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #FF4500, #8B0000);
            transition: width 0.2s;
        }
        
        #mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
            background: rgba(255,255,255,0.8);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        #mute-btn:active {
            transform: scale(0.9);
        }

        #attack-btn {
            position: absolute;
            bottom: 40px;
            left: 30px;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: #E76F51;
            border: 4px solid #fff;
            color: white;
            font-weight: 900;
            font-size: 1.2rem;
            display: none; 
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            align-items: center;
            justify-content: center;
        }
        #attack-btn:active { transform: scale(0.95); background: #d65d40; }

        #qte-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #qte-overlay.active {
            opacity: 1;
            background: radial-gradient(circle, transparent 20%, rgba(0,0,0,0.6) 90%);
        }
        #qte-prompt {
            font-size: 4rem;
            color: #FFF;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 0 0 20px #E76F51;
            transform: scale(0.5);
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #qte-overlay.active #qte-prompt {
            transform: scale(1.2);
        }
        .qte-bar-bg {
            width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }
        #qte-timer-fill {
            height: 100%;
            width: 100%;
            background: #E76F51;
            transform-origin: left;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(244, 247, 242, 0.95);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            pointer-events: auto;
            transition: opacity 0.4s, transform 0.4s;
            z-index: 10;
            box-sizing: border-box;
            overflow-y: auto; 
            touch-action: pan-y;
            justify-content: flex-start;
            padding-top: 40px;
            padding-bottom: 40px;
            -webkit-overflow-scrolling: touch;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
            z-index: -1;
        }

        .modal-overlay {
            background: rgba(0, 0, 0, 0.6);
            z-index: 100;
            justify-content: center;
            padding-top: 0;
        }

        h1 {
            color: #2F6F6F;
            font-size: 3.5rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.1);
            line-height: 1;
        }

        h2 {
            color: #4A5A6A;
            font-size: 1.2rem;
            margin: 10px 0 30px 0;
            font-weight: 400;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        h3 {
            color: #2F6F6F;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(47, 111, 111, 0.2);
            padding-bottom: 5px;
            display: inline-block;
        }
        
        p {
            color: #556677;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 320px;
            margin-bottom: 40px;
        }

        .btn {
            background: #2F6F6F;
            color: #F4F7F2;
            border: none;
            padding: 16px 30px;
            font-size: 1.1rem;
            font-weight: 800;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            box-shadow: 0 5px 15px rgba(47, 111, 111, 0.3);
            font-family: 'Montserrat', sans-serif;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(47, 111, 111, 0.4);
            background: #265959;
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(47, 111, 111, 0.3);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #2F6F6F;
            color: #2F6F6F;
            box-shadow: none;
        }
        .btn-secondary:hover {
            background: rgba(47, 111, 111, 0.05);
            color: #1a4040;
        }

        .btn-shop {
            background: #E9C46A;
            color: #1A2B3C;
            border: none;
        }
        .btn-shop:hover {
            background: #d4b058;
        }
        
        .btn-option {
            background: white;
            color: #2F6F6F;
            border: 2px solid #eee;
            text-transform: none;
            font-size: 0.95rem;
            padding: 12px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-bottom: 10px;
            text-align: left;
            line-height: 1.4;
            width: 100%;
            cursor: pointer;
        }
        .btn-option:hover {
            background: #f4f7f2;
            border-color: #2F6F6F;
            transform: translateY(-1px);
        }

        /* Info Panels */
        .info-panel {
            background: white;
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(47, 111, 111, 0.08);
            max-width: 650px;
            width: 90%;
            text-align: left;
            margin-bottom: 20px;
        }
        
        .info-list li {
            margin-bottom: 8px;
            color: #556677;
            list-style-type: none;
            position: relative;
            padding-left: 20px;
            font-size: 0.95rem;
        }
        .info-list li::before {
            content: '‚Ä¢'; color: #2F6F6F; font-weight: bold; position: absolute; left: 0;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .feature-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: rgba(244, 247, 242, 0.5);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer; 
        }

        .icon-circle {
            font-size: 24px;
            margin-bottom: 5px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        /* Shop Styles */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 600px;
            padding: 10px;
        }

        .shop-item {
            background: white;
            border-radius: 15px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            border: 3px solid transparent;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .shop-item:hover {
            transform: translateY(-2px);
        }

        .shop-item.active {
            border-color: #2F6F6F;
            background: #F0FAF9;
        }

        .skin-preview {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-bottom: 10px;
            border: 2px solid #eee;
        }

        .skin-name {
            font-weight: 800;
            color: #2F6F6F;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .skin-perk {
            font-size: 0.75rem;
            color: #556677;
            margin-bottom: 10px;
            min-height: 30px;
        }

        .skin-price {
            font-weight: bold;
            color: #E9C46A;
            background: #1A2B3C;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }
        
        .owned-tag {
            background: #2A9D8F;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            align-items: center;
            margin-bottom: 15px;
            background: white;
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        /* Badges */
        .badge-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .badge {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: #ccc;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
            filter: grayscale(1);
            opacity: 0.5;
            position: relative;
        }
        .badge.unlocked {
            filter: grayscale(0);
            opacity: 1;
            background: #FFD700;
            box-shadow: 0 0 10px gold;
        }

        /* Flash Effect */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(231, 111, 81, 0.4) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
            z-index: 4;
        }

        .stat-badge {
            background: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 900;
            color: #E9C46A;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            font-size: 1rem;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; letter-spacing: 4px; }
            h2 { font-size: 1rem; margin-bottom: 20px; }
            .shop-grid { grid-template-columns: 1fr; }
            .feature-grid { grid-template-columns: 1fr; gap: 10px; }
            .feature-item { flex-direction: row; gap: 15px; text-align: left; }
            .screen { backdrop-filter: blur(5px); }
            .btn { padding: 18px 30px; font-size: 1.2rem; }
            .btn-option { padding: 15px 20px; font-size: 1rem; }
            #mute-btn { bottom: 30px; right: 30px; width: 60px; height: 60px; }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="damage-overlay"></div>
    
    <div id="qte-overlay">
        <div id="qte-prompt">ACTION!</div>
        <div class="qte-bar-bg">
            <div id="qte-timer-fill"></div>
        </div>
    </div>

    <div id="boss-hud">
        <div class="boss-name">NEMESIS A.I.</div>
        <div class="boss-hp-bar">
            <div id="boss-hp-fill"></div>
        </div>
    </div>

    <button id="mute-btn" onclick="toggleAudio()">üîä</button>
    <div id="attack-btn" onclick="playerAttack()">‚öîÔ∏è</div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-block">
                <div class="score-label">Distance</div>
                <div class="score-val"><span id="score">0</span>m</div>
                <div class="highscore-in-game">Best: <span id="hud-highscore">0</span>m</div>
            </div>
            <div class="energy-wrapper">
                <div class="score-label">Comfort (Energy)</div>
                <div class="energy-bar-container">
                    <div id="energy-fill"></div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; padding-bottom: 20px; opacity: 0.6; font-size: 0.8rem; color: #2F6F6F;" id="controls-hint">
            Space/Up/W: Jump | Down/S: Dive | Mouse: Aim Sword | A/D: Boss Move
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <div style="font-size: 60px; color: #2F6F6F; margin-bottom: 10px;">‚ö°</div>
        <h1>AETHER</h1>
        <h2>Sustainable Comfort Run</h2>
        <div class="stat-badge">BEST: <span id="menu-highscore">0</span>m</div>
        <div class="currency-display" style="font-size: 1.2rem; margin-bottom: 20px;">
            <span id="menu-coins">0</span> Aether Coins
        </div>
        
        <div class="badge-grid" id="badge-container"></div>

        <div class="btn-group">
            <button class="btn" onclick="startGame()">Start Running</button>
            <button class="btn btn-secondary" onclick="cycleDifficulty()" id="diff-btn">Difficulty: Medium</button>
            <button class="btn btn-shop" onclick="openShop()">Aether Shop</button>
            <button class="btn btn-secondary" onclick="showScreen('product-screen')">Our Technology</button>
            <button class="btn btn-secondary" onclick="showScreen('instructions-screen')">How to Play</button>
        </div>
        <div style="opacity: 0.5; font-size: 0.8rem; margin-bottom: 20px;">v7.5 - Physics Polish</div>
    </div>

    <!-- Win Screen -->
    <div id="win-screen" class="screen hidden" style="justify-content: center; background: rgba(255,255,255,0.95);">
        <h1 style="color: #E9C46A; font-size: 4rem;">VICTORY</h1>
        <h2 style="color: #2F6F6F;">20,000M REACHED</h2>
        <p>You have mastered the Flow State.</p>
        <div class="btn-group">
            <button class="btn" onclick="continueEndless()">Continue (Endless)</button>
            <button class="btn btn-secondary" onclick="endGame('Victory Lap')">Finish Run</button>
        </div>
    </div>

    <!-- Product Page -->
    <div id="product-screen" class="screen hidden">
        <h2 style="margin-bottom: 5px; color: #E9C46A; font-size: 1rem; letter-spacing: 3px;">SUSTAINABLE PERFORMANCE</h2>
        <h1>AETHER TECH</h1>
        <div class="info-panel">
            <h3>The Seaweed x Merino Fusion</h3>
            <p>We've engineered the ultimate sportswear fabric by blending <strong>nutrient-rich Seaweed</strong> with <strong>premium Merino Wool</strong>.</p>
            <div class="feature-grid">
                <div class="feature-item">
                    <div class="icon-circle" style="color:#2F6F6F">üåø</div>
                    <div><strong>Bio-Active</strong><br><span style="font-size:0.8em">Seaweed transfers nutrients to skin.</span></div>
                </div>
                <div class="feature-item">
                    <div class="icon-circle" style="color:#E9C46A">‚òÄÔ∏è</div>
                    <div><strong>UV Shield</strong><br><span style="font-size:0.8em">Natural protection from solar rays.</span></div>
                </div>
                <div class="feature-item">
                    <div class="icon-circle" style="color:#2A9D8F">üí®</div>
                    <div><strong>Air-Woven</strong><br><span style="font-size:0.8em">3-Layer structure for max airflow.</span></div>
                </div>
            </div>
            <h3 style="margin-top: 20px;">The 3-Layer Structure</h3>
            <ul class="info-list">
                <li><strong>Inner Layer (Merino):</strong> Ultra-soft, antibacterial, and moisture-wicking.</li>
                <li><strong>Middle Layer (Air Pockets):</strong> Micro-cavities trap air for insulation.</li>
                <li><strong>Outer Layer (Wave Weave):</strong> A durable, wave-patterned shield.</li>
            </ul>
        </div>
        <button class="btn" style="max-width: 200px;" onclick="showScreen('start-screen')">Back to Menu</button>
    </div>

    <!-- Quiz Overlay -->
    <div id="quiz-screen" class="screen hidden" style="z-index: 50; justify-content: center;">
        <h2 style="color: #2F6F6F; margin-bottom: 10px;">AETHER TRIVIA</h2>
        <p>Answer correctly for <strong>50 Coins</strong> & a <strong>Powerup</strong>!</p>
        <div class="info-panel" style="width: 100%; max-width: 500px;">
            <h3 id="quiz-question" style="margin-bottom: 20px;">Question goes here...</h3>
            <div id="quiz-options" style="display: flex; flex-direction: column; gap: 10px;"></div>
        </div>
    </div>

    <!-- Reward Overlay -->
    <div id="reward-screen" class="screen hidden" style="z-index: 51; justify-content: center;">
        <h1 style="font-size: 2.5rem; color: #E9C46A;">CORRECT!</h1>
        <p>+50 Coins Added! Choose your buff:</p>
        <div class="feature-grid" style="margin-top: 10px;">
            <div class="feature-item" onclick="applyBuff('MAGNET')">
                <div class="icon-circle">üß≤</div>
                <div><strong>Magnet</strong><br>Attract Items</div>
            </div>
            <div class="feature-item" onclick="applyBuff('SHIELD_REGEN')">
                <div class="icon-circle">üõ°Ô∏è</div>
                <div><strong>Regen</strong><br>Shields Restore</div>
            </div>
            <div class="feature-item" onclick="applyBuff('EFFICIENCY')">
                <div class="icon-circle">üîã</div>
                <div><strong>Efficient</strong><br>Slower Drain</div>
            </div>
        </div>
    </div>

    <!-- Shop Screen -->
    <div id="shop-screen" class="screen hidden">
        <div class="shop-header">
            <h2 style="margin:0;">Aether Wardrobe</h2>
            <div class="currency-display"><span id="shop-coins">0</span> ü™ô</div>
        </div>
        <div id="shop-container" class="shop-grid"></div>
        <div class="btn-group" style="margin-top: 20px;">
            <button class="btn btn-secondary" onclick="showScreen('start-screen')">Back to Menu</button>
        </div>
    </div>

    <!-- Instructions Page -->
    <div id="instructions-screen" class="screen hidden">
        <h1>Field Guide</h1>
        <div class="info-panel" style="max-height: 70vh; overflow-y: auto;">
            <div class="feature-grid" style="margin-bottom: 20px;">
                <div class="feature-item">
                    <div class="icon-circle">üëÜ</div>
                    <div><strong>Tap / Space / W</strong><br>Jump</div>
                </div>
                <div class="feature-item">
                    <div class="icon-circle">üëá</div>
                    <div><strong>Swipe / Down / S</strong><br>Dive</div>
                </div>
            </div>
            <h3>Boss Controls</h3>
            <p>Use <strong>A / D</strong> to move Left/Right. <strong>Mouse</strong> aims Sword.</p>
            
            <h3>Aether Collectibles</h3>
            <ul class="info-list">
                <li><strong>Seaweed (Green Orb):</strong> Restores Energy (more with Eco-Boost skin).</li>
                <li><strong>Wool (White Orb):</strong> Restores one Shield.</li>
                <li><strong>Coin (Yellow $):</strong> Grants 10 Aether Coins.</li>
                <li><strong>Mystery Box (?):</strong> Grants 50 Coins or the Boss Sword (if available).</li>
            </ul>

            <h3>Hazards & Threats (Energy Loss)</h3>
            <ul class="info-list">
                <li><strong>Rock / Boulder:</strong> Standard ground obstacles requiring a jump.</li>
                <li><strong>Missile / Arrow:</strong> Fast-moving aerial projectiles.</li>
                <li><strong>Sun / Drone:</strong> Floating objects that drain energy on contact.</li>
                <li><strong>Drainer Drone:</strong> Deals energy damage and reduces speed temporarily.</li>
                <li><strong>Nullifier Drone:</strong> Removes all active buffs/powerups.</li>
                <li><strong>Lava Plume / Geyser:</strong> Terrain hazards that require precise timing (3000m+).</li>
                <li><strong>Electric Gate / Wave:</strong> Environmental barriers requiring careful timing or a QTE (3000m+).</li>
                <li><strong>Bat Swarm:</strong> Low-flying enemy group (dive or cut-jump necessary, 6000m+).</li>
                <li><strong>Boss Hazards:</strong> Lasers, seeker drones, and high-speed geometry in Dark Mode (7000m+).</li>
            </ul>
        </div>
        <button class="btn" style="max-width: 200px;" onclick="showScreen('start-screen')">Back</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden" style="justify-content: center;">
        <h1 style="font-size: 3rem; color: #E76F51;">Finished</h1>
        <p id="game-over-msg">Limit Reached</p>
        <div style="background: white; padding: 20px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); margin: 20px 0; width: 100%; max-width: 300px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="color: #888;">Distance</span>
                <span style="font-weight: bold; color: #2F6F6F;" id="final-score">0m</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color: #E9C46A; font-weight: bold;">
                <span>Best Run</span>
                <span id="game-over-best">0m</span>
            </div>
            <div style="display: flex; justify-content: space-between; border-top: 1px solid #eee; padding-top: 10px;">
                <span style="color: #888;">Earnings</span>
                <span style="font-weight: bold; color: #E9C46A;" id="coins-earned">+0 Coins</span>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn" onclick="resetGame()">Run Again</button>
            <button class="btn btn-shop" onclick="openShop()">Spend Coins</button>
            <button class="btn btn-secondary" onclick="showScreen('product-screen')">Tech Specs</button>
            <button class="btn btn-secondary" onclick="showScreen('start-screen')">Menu</button>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="custom-modal" class="screen hidden modal-overlay">
        <div class="info-panel" style="max-width: 300px; text-align: center; max-height: none;">
            <h3 id="modal-title">Shop</h3>
            <p id="modal-msg">Message</p>
            <div class="btn-group" style="flex-direction: row; justify-content: center;">
                <button id="modal-action-btn" class="btn btn-shop" style="padding: 10px 20px; font-size: 1rem;">OK</button>
                <button id="modal-close-btn" class="btn btn-secondary" style="padding: 10px 20px; font-size: 1rem;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<script>
    // --- MOUSE TRACKING ---
    let mouseX = 0;
    let mouseY = 0;
    window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    // --- AUDIO SYSTEM ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    class AudioSynth {
        constructor() {
            this.ctx = null;
            this.isMuted = false;
            this.isPlaying = false;
            this.musicPulse = 1.0; 
        }

        init() {
            if (!this.ctx) this.ctx = new AudioContext();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }

        playTone(freq, type, duration, vol=0.1, timeOffset=0) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            const now = this.ctx.currentTime + timeOffset;
            gain.gain.setValueAtTime(vol, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.start(now);
            osc.stop(now + duration);
        }

        playSFX(type) {
            if (this.isMuted || !this.ctx) return;
            const now = this.ctx.currentTime;

            if (type === 'jump') {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } 
            else if (type === 'coin') {
                this.playTone(1200, 'sine', 0.1, 0.05);
                this.playTone(1800, 'sine', 0.2, 0.03, 0.05);
            } 
            else if (type === 'crash') {
                this.playTone(100, 'sawtooth', 0.3, 0.2);
            } 
            else if (type === 'powerup') {
                this.playTone(523.25, 'sine', 0.2, 0.1, 0);   
                this.playTone(659.25, 'sine', 0.2, 0.1, 0.1); 
                this.playTone(783.99, 'sine', 0.4, 0.1, 0.2); 
            }
            else if (type === 'mystery') {
                this.playTone(400, 'square', 0.1, 0.1, 0);
                this.playTone(600, 'square', 0.1, 0.1, 0.1);
            }
            else if (type === 'click') {
                this.playTone(800, 'triangle', 0.05, 0.05);
            }
            else if (type === 'slowmo') {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 1.0);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now); osc.stop(now + 1.0);
            }
            else if (type === 'laser') {
                this.playTone(800, 'sawtooth', 0.5, 0.2);
                this.playTone(400, 'square', 0.5, 0.2);
            }
            else if (type === 'boss_hit') {
                 this.playTone(200, 'square', 0.1, 0.3);
            }
        }

        startBGM() {
            if (this.isPlaying) return;
            if (this.isMuted || !this.ctx) return;
            this.isPlaying = true;
            this.playLoop();
        }

        stopBGM() {
            this.isPlaying = false;
            if (this.bgmTimer) clearTimeout(this.bgmTimer);
        }

        playLoop() {
            if (!this.isPlaying) return;
            let sequence = [262, 330, 392, 523, 392, 330, 294, 349];
            if (postBossMode) sequence = [50, 60, 50, 80, 50, 100]; // darker theme
            let tempo = 300;
            if (timeScale < 0.5) tempo = 1200; 
            if (postBossMode) tempo = 150; // faster
            
            let noteIndex = 0;
            
            const playNext = () => {
                if (!this.isPlaying) return;
                const freq = sequence[noteIndex % sequence.length];
                this.playTone(freq / 2, 'triangle', 0.5, 0.02); 
                this.playTone(freq, 'sine', 0.4, 0.02); 
                if (noteIndex % 4 === 0) this.musicPulse = 1.2; 
                noteIndex++;
                this.bgmTimer = setTimeout(playNext, tempo);
            };
            playNext();
        }

        toggleMute() {
            this.isMuted = !this.isMuted;
            const btn = document.getElementById('mute-btn');
            btn.innerText = this.isMuted ? 'üîá' : 'üîä';
            if (!this.isMuted && this.isPlaying) this.playLoop();
            if (this.isMuted) this.stopBGM();
        }
    }

    const audio = new AudioSynth();
    function toggleAudio() {
        audio.init();
        audio.toggleMute();
    }
    
    let audioUnlocked = false;
    function unlockAudio() {
        if (audioUnlocked) return;
        if (audio.ctx && audio.ctx.state === 'suspended') {
            audio.ctx.resume().then(() => {
                audioUnlocked = true;
            });
        }
    }
    window.addEventListener('touchstart', unlockAudio, {once:true});
    window.addEventListener('click', unlockAudio, {once:true});

    // --- System & Config ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const PALETTE = {
        danger: '#E76F51',
        sun: '#E9C46A'
    };
    
    const BADGES = [
        { id: 'novice', icon: 'ü•â', desc: 'Run 1000m' },
        { id: 'runner', icon: 'ü•à', desc: 'Run 5000m' },
        { id: 'champion', icon: 'ü•á', desc: 'Defeat Boss' },
        { id: 'legend', icon: 'üëë', desc: 'Reach 20,000m' },
        { id: 'rich', icon: 'üí∞', desc: 'Collect 1000 Coins total' }
    ];

    const SKINS = [
        { id: 'default', name: 'The Prototype', desc: 'Pure black. No Aether tech. Heavy.', cost: 0, color: '#111111', secondary: '#333333', scarf: '#444444', perk: 'none' },
        { id: 'teal', name: 'Breeze Veil', desc: 'Photosynthesis: Sun damage -50%.', cost: 200, color: '#9BB1D6', secondary: '#6E85B2', scarf: '#2F6F6F', perk: 'photosynthesis' },
        { id: 'beige', name: 'Sunspire Shores', desc: 'Max Shield: 2. Start with 1.', cost: 500, color: '#E3D5CA', secondary: '#D5BDAF', scarf: '#F4F7F2', perk: 'shield_start' },
        { id: 'pink', name: 'Coral Blush', desc: 'Vitality: +30 Max Energy.', cost: 1000, color: '#F2CCC4', secondary: '#E29587', scarf: '#FFD166', perk: 'vitality' },
        { id: 'blue', name: 'Salty Haze', desc: 'Lightweight: Higher jumps.', cost: 1600, color: '#E0F4F4', secondary: '#B4D9D9', scarf: '#F1FAEE', perk: 'lightweight' },
        { id: 'green', name: 'Kelp Sprout', desc: 'Absorb: Seaweed = 2x Energy.', cost: 2400, color: '#C8D9B3', secondary: '#90A955', scarf: '#D8F3DC', perk: 'eco_boost' }
    ];

    const QUESTIONS = [
        { q: "What materials are in the Aether set?", opts: ["Cotton/Poly", "Seaweed/Merino", "Bamboo/Spandex", "Nylon/Lycra"], ans: 1 },
        { q: "Standard set includes?", opts: ["Jacket/Leggings", "T-shirt/Shorts", "Hoodie/Pants", "Two T-shirts"], ans: 1 },
        { q: "Fabric construction?", opts: ["Single knit", "Double weave", "3-layer woven", "Fleece"], ans: 2 },
        { q: "Middle layer function?", opts: ["Durability", "Antibacterial", "Air pockets", "UV Shield"], ans: 2 },
        { q: "Which layer is 'ultra-soft'?", opts: ["Inner", "Middle", "Outer", "All"], ans: 0 },
        { q: "Outer layer feature?", opts: ["Air pockets", "Waterproof", "Wave-weave", "Fleece"], ans: 2 },
        { q: "Natural UV protection source?", opts: ["Merino", "Seaweed", "Air", "Dye"], ans: 1 },
        { q: "Who is the set for?", opts: ["Men", "Women", "Kids", "Unisex"], ans: 3 }
    ];

    const DIFFICULTIES = {
        EASY: { label: "Easy", speed: 9, progression: 0.001, drain: 0.3 }, 
        MEDIUM: { label: "Medium", speed: 11, progression: 0.0015, drain: 0.6 }, 
        HARD: { label: "Hard", speed: 14, progression: 0.002, drain: 0.9 }, 
        FLOW: { label: "Flow", speed: 18, progression: 0.003, drain: 1.2 }  
    };
    const DIFF_KEYS = ['EASY', 'MEDIUM', 'HARD', 'FLOW'];
    let selectedDifficulty = 'MEDIUM';

    // --- SAVE SYSTEM ---
    let playerData = JSON.parse(localStorage.getItem('aether_player_v4')) || {
        coins: 0,
        ownedSkins: ['default'],
        equippedSkin: 'default',
        badges: []
    };
    let highScore = localStorage.getItem('aether_highscore_v4') || 0;

    function saveGame() {
        localStorage.setItem('aether_player_v4', JSON.stringify(playerData));
        updateCoinDisplays();
        renderBadges();
    }

    function updateCoinDisplays() {
        document.getElementById('menu-coins').innerText = playerData.coins;
        document.getElementById('shop-coins').innerText = playerData.coins;
        document.getElementById('menu-highscore').innerText = Math.floor(highScore);
    }
    
    function unlockBadge(id) {
        if (!playerData.badges.includes(id)) {
            playerData.badges.push(id);
            saveGame();
            spawnFloatingText(canvas.width/2, canvas.height/2, "BADGE UNLOCKED!", "#FFD700");
            audio.playSFX('powerup');
        }
    }

    function renderBadges() {
        const container = document.getElementById('badge-container');
        container.innerHTML = '';
        BADGES.forEach(b => {
            const unlocked = playerData.badges.includes(b.id);
            const div = document.createElement('div');
            div.className = `badge ${unlocked ? 'unlocked' : ''}`;
            div.innerText = b.icon;
            div.title = b.desc;
            container.appendChild(div);
        });
    }

    function getEquippedSkin() {
        return SKINS.find(s => s.id === playerData.equippedSkin) || SKINS[0];
    }

    // --- GAME CONSTANTS & QTE VARS ---
    const GRAVITY = 0.8;          
    const BASE_JUMP_FORCE = -18.5; 
    const DIVE_FORCE = 25;
    const MAX_SPEED = 28;    
    
    let gameState = 'MENU';
    let frameId;
    let score = 0;
    let gameSpeed = 8.0; 
    let timeScale = 1.0; 
    let energy = 100;
    let maxEnergy = 100;
    let frameCount = 0;
    let groundY; 
    let dayTime = 0; 
    let sessionCoins = 0;
    let jumpBuffer = 0; 
    let coyoteTime = 0;
    let nextQuizThreshold = 700; 
    let buffs = { magnet: false, shieldRegen: false, efficiency: false };
    let floatingTexts = []; 
    let shakeTimer = 0;
    
    // QTE Variables
    let qteActive = false;
    let qteTargetAction = null; 
    let qteTimer = 0;
    let qteMaxTime = 60; 
    let qteTargetObstacle = null;
    let invulnerableTimer = 0;

    // BOSS VARIABLES
    let bossBattleActive = false;
    let boss = null;
    let bossDefeated = false;
    let postBossMode = false;
    let winTriggered = false;

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 1.0; this.vy = -2;
        }
        update() {
            this.y += this.vy * timeScale;
            this.life -= 0.02 * timeScale;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.font = "900 20px Montserrat";
            ctx.textAlign = "center";
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 4;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    function spawnFloatingText(x, y, text, color) {
        floatingTexts.push(new FloatingText(x, y, text, color));
    }

    // --- DYNAMIC TERRAIN SYSTEM ---
    class TerrainManager {
        constructor() {
            this.segments = [];
            this.segmentLength = 200;
            this.platforms = [];
            this.segmentsSinceLava = 10; 
        }

        reset() {
            this.segments = [];
            this.platforms = [];
            this.segmentsSinceLava = 10;
            for(let i = 0; i < 10; i++) {
                this.addSegment(i * this.segmentLength, groundY, 'NORMAL');
            }
        }

        generateValidNextSegment(lastSeg) {
             let nextX = lastSeg.x + lastSeg.width;
             let nextY = lastSeg.y;
             let nextType = 'NORMAL';

             if (bossBattleActive) {
                 nextY = canvas.height - 100;
                 return { x: nextX, y: nextY, type: 'BOSS_ARENA' };
             }

             if (score > 2500 && this.segmentsSinceLava >= 3 && Math.random() < 0.25) {
                 nextType = 'LAVA';
                 this.segmentsSinceLava = 0;
             } else {
                 this.segmentsSinceLava++;
                 if (Math.random() < 0.5) {
                     // Scale variance by speed: faster speed = flatter terrain
                     let maxDiff = 25 * (10 / Math.max(10, gameSpeed)); 
                     let diff = (Math.random() * maxDiff + 5); 
                     if (Math.random() > 0.5) nextY -= diff; 
                     else nextY += diff; 
                 }
                 // Keep ground reachable
                 if (nextY > canvas.height - 50) nextY = canvas.height - 50;
                 if (nextY < canvas.height - 300) nextY = canvas.height - 300;
             }
             return { x: nextX, y: nextY, type: nextType };
        }

        addSegment(x, y, type) {
            if (this.segments.length > 0 && x === undefined) {
                 const last = this.segments[this.segments.length-1];
                 const next = this.generateValidNextSegment(last);
                 x = next.x; y = next.y; type = next.type;
            }

            let grad;
            let decorations = [];

            if (type === 'NORMAL' || type === 'BOSS_ARENA') {
                grad = ctx.createLinearGradient(0, y, 0, y + 400);
                if (postBossMode) {
                    grad.addColorStop(0, '#000000'); // High Contrast Black
                    grad.addColorStop(1, '#111111');
                } else {
                    grad.addColorStop(0, '#E6EBE0');
                    grad.addColorStop(0.1, '#D0D8D9');
                    grad.addColorStop(1, '#AAB7B8');
                }

                const numDetails = Math.floor(Math.random() * 3) + 3;
                for (let k = 0; k < numDetails; k++) {
                    decorations.push({
                        x: Math.random() * this.segmentLength,
                        y: Math.random() * 200 + 20, 
                        size: Math.random() * 6 + 2,
                        shape: Math.random() > 0.5 ? 'circle' : 'rect',
                        color: postBossMode ? '#333' : (Math.random() > 0.5 ? 'rgba(47, 111, 111, 0.08)' : 'rgba(255, 255, 255, 0.3)')
                    });
                }

            } else if (type === 'LAVA') {
                grad = ctx.createLinearGradient(0, y, 0, y + 50);
                grad.addColorStop(0, '#FF4500'); 
                grad.addColorStop(1, '#8B0000');
            }

            this.segments.push({
                x: x, y: y, width: this.segmentLength, type: type, gradient: grad, decorations: decorations
            });

            let prevY = (this.segments.length > 1) ? this.segments[this.segments.length-2].y : y;

            if (type === 'LAVA') {
                let platY = prevY - 100 - Math.random() * 100;
                if (platY < 150) platY = 150; 
                this.addPlatform(x + 20, platY);
                this.addPlatform(x + 130, platY - (Math.random() * 60 - 30)); 
                if (Math.random() < 0.5) { obstacles.push(new Obstacle('LAVA_PLUME', x + 100, canvas.height)); }
            } 
            else if (Math.random() < 0.3 && type !== 'BOSS_ARENA') {
                 const upward_slope = prevY - y; 
                 if (upward_slope <= 10) { 
                     let platY = y - 90 - Math.random() * 60;
                     this.addPlatform(x + 50, platY);
                 }
            }
        }

        addPlatform(x, y) {
            let widthType = Math.random();
            let w = 150; 
            if (widthType < 0.3) w = 80 + Math.random() * 30; 
            else if (widthType < 0.7) w = 140 + Math.random() * 40; 
            else w = 220 + Math.random() * 60; 
            this.platforms.push(new Platform(x, y, w));
        }

        update() {
            let speed = (bossBattleActive) ? 0 : gameSpeed * timeScale;
            for (let i = this.segments.length - 1; i >= 0; i--) { this.segments[i].x -= speed; }
            for (let i = this.platforms.length - 1; i >= 0; i--) { this.platforms[i].x -= speed; }

            if (this.segments[0].x + this.segments[0].width < -100) this.segments.shift();
            this.platforms = this.platforms.filter(p => p.x + p.width > -100);

            let lastSeg = this.segments[this.segments.length - 1];
            if (lastSeg.x + lastSeg.width < canvas.width + 200) {
                const next = this.generateValidNextSegment(lastSeg);
                this.addSegment(next.x, next.y, next.type);
            }
        }

        draw(ctx) {
            for(let s of this.segments) {
                if (s.type === 'NORMAL' || s.type === 'BOSS_ARENA') {
                    ctx.fillStyle = s.gradient;
                    ctx.fillRect(s.x, s.y, s.width + 2, canvas.height - s.y);
                    
                    for (let d of s.decorations) {
                        ctx.fillStyle = d.color;
                        if (d.shape === 'circle') { ctx.beginPath(); ctx.arc(s.x + d.x, s.y + d.y, d.size, 0, Math.PI*2); ctx.fill(); } 
                        else { ctx.fillRect(s.x + d.x, s.y + d.y, d.size * 1.5, d.size); }
                    }

                    if (postBossMode) {
                        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(s.x, s.y, s.width + 2, 8); // White surface
                    } else {
                        ctx.fillStyle = '#2F6F6F'; ctx.fillRect(s.x, s.y, s.width + 2, 8); 
                        ctx.fillStyle = '#A8C686'; ctx.fillRect(s.x, s.y, s.width + 2, 3);
                    }

                } else if (s.type === 'LAVA') {
                    let wave = Math.sin(frameCount * 0.1 + s.x * 0.05) * 5;
                    ctx.fillRect(s.x, s.y + 10 + wave, s.width, canvas.height);
                    ctx.fillStyle = 'rgba(255, 200, 0, 0.5)';
                    if (frameCount % 20 === 0) { ctx.beginPath(); ctx.arc(s.x + Math.random() * s.width, s.y + Math.random() * 20, Math.random() * 5, 0, Math.PI*2); ctx.fill(); }
                }
            }
            for(let p of this.platforms) p.draw(ctx);
        }

        getSegmentAt(x) { return this.segments.find(s => x >= s.x && x < s.x + s.width); }
    }

    class Platform {
        constructor(x, y, w) { this.x = x; this.y = y; this.width = w; this.height = 20; }
        draw(ctx) {
            ctx.strokeStyle = postBossMode ? "#00FFFF" : "#FFFFFF";
            ctx.lineWidth = 4;
            ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = postBossMode ? '#111' : '#6E7F80';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = postBossMode ? '#FFF' : '#A8C686';
            ctx.fillRect(this.x, this.y, this.width, 6);
        }
    }

    class Boss {
        constructor() {
            this.x = canvas.width - 200;
            this.y = 200;
            this.width = 120;
            this.height = 120;
            this.maxHp = 200; // Increased HP
            this.hp = 200;
            this.moveTimer = 0;
            this.attackTimer = 0;
            this.state = 'IDLE'; 
            this.floatY = 0;
            this.targetY = 200;
        }
        
        update() {
            this.floatY = Math.sin(frameCount * 0.05) * 20;
            this.moveTimer++;
            this.targetY = player.y - 50;
            this.y += (this.targetY - this.y) * 0.08; // Faster tracking

            if (this.moveTimer > 60) {
                this.x = (canvas.width / 2) + Math.random() * 300;
                this.moveTimer = 0;
            }
            
            this.attackTimer++;
            // Attacks faster as HP drops
            let threshold = 100;
            if (this.hp < 100) threshold = 60;
            if (this.hp < 50) threshold = 40;

            if (this.attackTimer > threshold) {
                this.attack();
                this.attackTimer = 0;
            }
            
            if (player.isAttacking) {
                let dx = player.x - this.x; let dy = player.y - this.y; let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 150) {
                    this.takeDamage(15);
                    player.isAttacking = false; 
                    createParticles(this.x + 60, this.y + 60, 20, '#FF0000');
                    spawnFloatingText(this.x, this.y, "-15", "#FF0000");
                    audio.playSFX('boss_hit');
                }
            }
        }
        
        attack() {
            let r = Math.random();
            // New LASER BEAM attack
            if (r < 0.3) {
                let beam = new Obstacle('LASER_BEAM', 0, this.y + 60);
                beam.warningTimer = 40; // Telegraph
                obstacles.push(beam);
            } else {
                let type = Math.random() < 0.6 ? 'MISSILE' : 'ARROW';
                let obs = new Obstacle(type, this.x, this.y + 50);
                obs.speedX = 25; 
                let angle = Math.atan2((player.y + player.height/2) - (this.y + 50), (player.x + player.width/2) - this.x);
                obs.vy = Math.sin(angle) * 12;
                obstacles.push(obs);
            }
        }
        
        takeDamage(amt) {
            this.hp -= amt;
            document.getElementById('boss-hp-fill').style.width = (this.hp / this.maxHp * 100) + '%';
            if (this.hp <= 0) {
                bossDefeated = true;
                bossBattleActive = false;
                postBossMode = true;
                player.hasSword = false;
                spawnFloatingText(this.x, this.y, "NEMESIS DESTROYED", "#FFF");
                document.getElementById('boss-hud').style.display = 'none';
                document.getElementById('attack-btn').style.display = 'none';
                unlockBadge('champion');
                
                // FORCE PLAYER LEFT
                player.forceResetToLeft = true;
                player.vx = 0;
            }
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2 + this.floatY);
            ctx.shadowColor = '#FF0000'; ctx.shadowBlur = 40;
            
            // Body - More menacing
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.moveTo(0, -70); ctx.lineTo(60, 0); ctx.lineTo(0, 70); ctx.lineTo(-60, 0);
            ctx.fill();
            
            // Inner Core
            ctx.fillStyle = `rgba(255, 0, 0, ${Math.random() * 0.5 + 0.5})`;
            ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2); ctx.fill();
            
            ctx.restore();
        }
    }

    class WeatherSystem {
        constructor() { this.type = 'CLEAR'; this.particles = []; this.timer = 0; }
        update() {
            this.timer++;
            if (this.timer > 1200 + Math.random() * 1200) { this.changeWeather(); this.timer = 0; }
            if (postBossMode) this.type = 'VOID'; 
            
            if (this.type === 'VOID') {
                 // Digital rain / debris up
                 if (frameCount % 2 === 0) this.particles.push({x: Math.random()*canvas.width, y: canvas.height, vx: 0, vy: -5-Math.random()*5, type: 'glitch', size: 2+Math.random()*4});
            } else if (this.type === 'RAIN' || this.type === 'STORM') {
                let limit = this.type==='STORM'?4:2;
                for(let i=0; i< limit; i++) {
                    this.particles.push({ x: Math.random() * canvas.width + canvas.width*0.2, y: -10, vx: -3-Math.random()*2, vy: 10+Math.random()*5, type: 'rain', len: 10+Math.random()*10 });
                }
            }
            for(let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i]; p.x+=p.vx*timeScale; p.y+=p.vy*timeScale; 
                if(p.y>canvas.height || p.y < -50) this.particles.splice(i,1);
            }
        }
        draw(ctx) {
            ctx.save();
            for(let p of this.particles) {
                 if (p.type === 'rain') { ctx.strokeStyle = '#AACCFF'; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - 2, p.y + p.len); ctx.stroke(); } 
                 else if (p.type === 'glitch') { ctx.fillStyle = '#00FF00'; ctx.fillRect(p.x, p.y, p.size, p.size*3); }
            }
            ctx.restore();
        }
        changeWeather() { const types=['CLEAR','RAIN','SNOW','STORM']; this.type=types[Math.floor(Math.random()*types.length)]; }
    }
    
    class ParallaxLayer {
        constructor(speedFactor, yOffset, height, color, complexity) { this.speedFactor=speedFactor; this.yOffset=yOffset; this.height=height; this.color=color; this.points=[]; this.generate(complexity); }
        generate(complexity) { this.points=[]; let x=0; this.points.push({x:0, y:this.height}); while(x<canvas.width+200){ let w=50+Math.random()*100; let h=(Math.random()-0.5)*complexity; x+=w; this.points.push({x:x,y:this.height+h}); } }
        update() {
             let speed = (bossBattleActive) ? 0 : gameSpeed * this.speedFactor * timeScale;
             for(let p of this.points) p.x-=speed;
             if(this.points[0].x<-150){ this.points.shift(); let lastP=this.points[this.points.length-1]; let w=50+Math.random()*100; this.points.push({x:lastP.x+w, y:this.height+(Math.random()-0.5)*40}); }
        }
        draw(ctx) { 
            ctx.fillStyle=postBossMode ? '#000' : this.color; 
            if(postBossMode) ctx.strokeStyle = '#333';
            ctx.beginPath(); ctx.moveTo(0,canvas.height); for(let p of this.points){ ctx.lineTo(p.x, canvas.height-50-p.y); } ctx.lineTo(canvas.width+100,canvas.height); ctx.lineTo(0,canvas.height); ctx.fill(); 
            if(postBossMode) ctx.stroke();
        }
    }
    const SKY_COLORS = { dawn:{top:'#FF9A9E',bot:'#FECFEF'}, noon:{top:'#A8DADC',bot:'#F4F7F2'}, dusk:{top:'#2F1C53',bot:'#F6D365'}, night:{top:'#0F2027',bot:'#203A43'} };
    function lerpColor(a,b,t) { let ah=parseInt(a.replace(/#/g,''),16), ar=ah>>16, ag=(ah>>8)&0xff, ab=ah&0xff, bh=parseInt(b.replace(/#/g,''),16), br=bh>>16, bg=(bh>>8)&0xff, bb=bh&0xff, rr=ar+t*(br-ar), rg=ag+t*(bg-ag), rb=ab+t*(bb-ab); return '#'+((1<<24)+(Math.round(rr)<<16)+(Math.round(rg)<<8)+Math.round(rb)).toString(16).slice(1); }
    let bgLayers=[]; function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; groundY=canvas.height-(canvas.height*0.15); bgLayers=[new ParallaxLayer(0.1,100,150,"rgba(47,111,111,0.3)",50), new ParallaxLayer(0.3,50,80,"rgba(47,111,111,0.5)",30)]; }
    window.addEventListener('resize', resize);

    class Player {
        constructor() {
            this.skin = getEquippedSkin();
            this.width = 30; this.height = 50;
            this.x = canvas.width * 0.15;
            this.y = groundY - this.height;
            this.vy = 0; this.vx = 0; 
            this.isJumping = false;
            this.shieldCount = 0; this.maxShields = 1; this.shieldRegenTimer = 0;
            this.scarfPoints = [];
            this.hasSword = false;
            this.isAttacking = false;
            this.attackCooldown = 0;
            this.forceResetToLeft = false;
            
            this.jumpMod = this.skin.perk === 'lightweight' ? 1.2 : 1.0;
            this.gravityMod = this.skin.perk === 'lightweight' ? 0.85 : 1.0;
            if (this.skin.perk === 'shield_start') { this.shieldCount = 1; this.maxShields = 2; }
            if (this.skin.perk === 'vitality') { maxEnergy = 130; energy = 130; } else { maxEnergy = 100; energy = 100; }
            for(let i=0; i<10; i++) this.scarfPoints.push({x: this.x, y: this.y});
        }
        update() {
            if (this.forceResetToLeft) {
                // Smoothly slide back to left
                let targetX = canvas.width * 0.15;
                this.x += (targetX - this.x) * 0.05;
                if (Math.abs(this.x - targetX) < 5) {
                    this.x = targetX;
                    this.forceResetToLeft = false;
                    this.vx = 0; // Ensure reset
                }
            } else {
                this.x += this.vx * timeScale;
            }

            if (jumpBuffer > 0) { jumpBuffer--; if (!this.isJumping || coyoteTime > 0) { this.jump(); jumpBuffer = 0; } }
            
            let prevY = this.y;
            this.y += this.vy * timeScale;
            
            // Keep in bounds
            if (this.x < 0) this.x = 0;
            if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;

            let segment = terrain.getSegmentAt(this.x + this.width/2);
            let groundLevel = segment ? segment.y : canvas.height + 100; 
            if (coyoteTime > 0) coyoteTime--;
            let onPlatform = false;
            let playerBottom = this.y + this.height;
            let prevBottom = prevY + this.height;
            for (let p of terrain.platforms) {
                if (this.x + this.width > p.x && this.x < p.x + p.width) {
                    if (this.vy >= 0) { if (playerBottom >= p.y && prevBottom <= p.y + 15) { this.y = p.y - this.height; this.vy = 0; this.isJumping = false; onPlatform = true; coyoteTime = 10; } }
                }
            }
            if (!onPlatform) {
                if (this.y + this.height >= groundLevel) {
                    if (segment.type === 'LAVA') { this.y += 1 * timeScale; energy -= 5 * timeScale; createParticles(this.x, this.y + this.height, 2, '#FF0000'); } 
                    else { this.y = groundLevel - this.height; this.vy = 0; this.isJumping = false; coyoteTime = 10; }
                } else { this.vy += (GRAVITY * this.gravityMod) * timeScale; this.isJumping = true; }
            }
            if (buffs.shieldRegen && this.shieldCount < this.maxShields) { this.shieldRegenTimer++; if (this.shieldRegenTimer > 600) { this.shieldCount++; this.shieldRegenTimer = 0; createParticles(this.x, this.y, 10, '#FFF'); audio.playSFX('powerup'); spawnFloatingText(this.x, this.y, "Shield Regened", "#FFF"); } }
            
            let prevX = this.x + 10; prevY = this.y + 10; 
            this.scarfPoints.forEach((p, index) => {
                let dx = p.x - prevX; let dy = p.y - prevY; let dist = Math.sqrt(dx*dx + dy*dy); let speed = (bossBattleActive ? 0 : gameSpeed) * 0.8 * timeScale; 
                if (dist > 5) { p.x -= (dx * 0.3) + speed; p.y -= dy * 0.3; } p.y += Math.sin(frameCount * 0.2 + index) * 2 * timeScale; prevX = p.x; prevY = p.y;
            });
            if (invulnerableTimer > 0) invulnerableTimer -= timeScale;
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.isAttacking && this.attackCooldown <= 0) this.isAttacking = false;
        }
        jump() { if (!this.isJumping || coyoteTime > 0) { this.vy = BASE_JUMP_FORCE * this.jumpMod; this.isJumping = true; coyoteTime = 0; createParticles(this.x + this.width/2, this.y + this.height, 5, '#FFF'); audio.playSFX('jump'); } else { jumpBuffer = 6; } }
        superJump() { this.vy = BASE_JUMP_FORCE * 1.8; this.isJumping = true; createParticles(this.x, this.y + this.height, 20, '#00FFFF'); audio.playSFX('whoosh'); invulnerableTimer = 60; }
        superDive() { this.vy = DIVE_FORCE * 1.5; createParticles(this.x, this.y, 15, '#FF0000'); audio.playSFX('whoosh'); invulnerableTimer = 30; }
        cutJump() { if (this.vy < -5) this.vy = this.vy * 0.4; }
        dive() { if (this.isJumping) { this.vy = DIVE_FORCE; createParticles(this.x, this.y, 3, '#FFF'); } }
        
        attack() {
            if (this.hasSword && this.attackCooldown <= 0) {
                this.isAttacking = true;
                this.attackCooldown = 20; 
                audio.playSFX('whoosh');
            }
        }

        draw() {
            ctx.beginPath(); ctx.moveTo(this.x + 10, this.y + 10);
            for (let i = 0; i < this.scarfPoints.length; i++) { const p = this.scarfPoints[i]; let nextP = this.scarfPoints[i+1] || p; let xc = (p.x + nextP.x) / 2; let yc = (p.y + nextP.y) / 2; ctx.quadraticCurveTo(p.x, p.y, xc, yc); }
            ctx.lineWidth = 6; ctx.strokeStyle = this.skin.scarf; ctx.lineCap = 'round'; ctx.stroke();
            if (this.shieldCount > 0) { ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI*2); ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; ctx.fill(); ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineWidth = 2; ctx.stroke(); }
            ctx.fillStyle = this.skin.secondary;
            if (this.isJumping) { ctx.fillRect(this.x + 5, this.y + 40, 8, 15); ctx.fillRect(this.x + 20, this.y + 35, 8, 20); } 
            else { let stride = Math.sin(frameCount * 0.3) * 10; ctx.beginPath(); ctx.moveTo(this.x + 15, this.y + 40); ctx.lineTo(this.x + 5 - stride, this.y + 50 + stride); ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x + 15, this.y + 40); ctx.lineTo(this.x + 25 + stride, this.y + 50 - stride); ctx.strokeStyle = this.skin.secondary; ctx.lineWidth = 8; ctx.stroke(); }
            ctx.fillStyle = this.skin.color; ctx.beginPath(); ctx.roundRect(this.x, this.y + 10, this.width, 35, 5); ctx.fill();
            if (invulnerableTimer > 0) { ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random()})`; ctx.lineWidth = 2; ctx.strokeRect(this.x - 2, this.y + 8, this.width + 4, 39); }
            ctx.fillStyle = this.skin.secondary; ctx.beginPath(); ctx.arc(this.x + 18, this.y + 5, 12, 0, Math.PI*2); ctx.fill();
            
            if (this.hasSword) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                let angle = Math.atan2(mouseY - (this.y + this.height/2), mouseX - (this.x + this.width/2));
                ctx.rotate(angle);
                if (this.isAttacking) { ctx.rotate(Math.sin(frameCount * 0.8) * 1.5); }
                ctx.fillStyle = '#00FFFF'; ctx.fillRect(10, -5, 40, 5); 
                ctx.fillStyle = '#555'; ctx.fillRect(0, -5, 10, 5); 
                ctx.restore();
            }
        }
    }

    class Obstacle {
        constructor(type, xOverride, yOverride) {
            this.type = type; this.speedX = 0; this.damage = 15; this.qteTriggered = false; 
            this.warningTimer = 0;
            let spawnY = terrain.segments[terrain.segments.length-1].y;

            // --- STANDARD ENEMIES ---
            if (type === 'MISSILE') { this.width = 60; this.height = 30; this.y = Math.random() > 0.5 ? spawnY - 130 : spawnY - 40; this.speedX = 6 + Math.random() * 3; this.damage = 25; } 
            else if (type === 'ARROW') { this.width = 40; this.height = 10; this.y = spawnY - 60 - Math.random() * 60; this.speedX = 15; this.damage = 20; }
            else if (type === 'SUN') { this.width = 40; this.height = 40; this.y = spawnY - 80 - (Math.random() * 100); this.damage = 30; } 
            else if (type === 'DRONE' || type === 'DRAINER' || type === 'NULLIFIER' || type === 'SEEKER_DRONE') { 
                this.width = 25; this.height = 15; this.y = spawnY - 150 - (Math.random() * 80); this.speedX = 10 + Math.random() * 5; this.damage = 40; 
                if(type === 'SEEKER_DRONE') this.speedX = 12;
            } 
            else if (type === 'WAVE') { this.width = canvas.width / 4; this.height = 60; this.x = canvas.width; this.y = spawnY - this.height + 5; this.speedX = -5; this.damage = 50; } 
            else if (type === 'LAVA_PLUME') { this.width = 40; this.height = 120; this.x = xOverride; this.y = yOverride; this.targetY = yOverride - 200; this.damage = 35; this.speedX = 0; } 
            
            // --- MID-GAME ENEMIES (3000-7000) ---
            else if (type === 'ELECTRIC_GATE') { this.width = 20; this.height = 200; this.y = spawnY - 200; this.damage = 30; }
            else if (type === 'ROLLING_BOULDER') { this.width = 60; this.height = 60; this.y = spawnY - 60; this.speedX = -5; this.damage = 35; }
            else if (type === 'GEYSER') { this.width = 50; this.height = 10; this.y = spawnY; this.damage = 25; this.isRising = true; }
            else if (type === 'BAT_SWARM') { this.width = 80; this.height = 40; this.y = spawnY - 100; this.damage = 10; this.speedX = 10; }

            // --- POST-BOSS ENEMIES (7000+) ---
            else if (type === 'LASER_BEAM') { this.width = canvas.width; this.height = 10; this.x = 0; this.y = yOverride || (spawnY - 50 - Math.random()*150); this.damage = 40; this.speedX = 0; }
            else if (type === 'GLITCH_PIXEL') { this.width = 40; this.height = 40; this.y = spawnY - 50; this.damage = 30; }
            else if (type === 'RED_WALL') { this.width = 30; this.height = 300; this.y = spawnY - 300; this.damage = 50; }
            else if (type === 'SPIKE_CEILING') { this.width = 100; this.height = 40; this.y = 0; this.damage = 40; }
            
            else { this.width = 40; this.height = 50; this.y = spawnY - this.height - 5; this.damage = 15; } // ROCK
            
            if (!xOverride && type !== 'LASER_BEAM' && type !== 'SPIKE_CEILING') this.x = canvas.width + Math.random() * 100;
            if (type === 'SPIKE_CEILING') this.x = canvas.width;
            
            this.isMoving = Math.random() < 0.4; this.angle = 0; this.vy = type === 'FLYING_ROCK' ? -(14 + Math.random()*4) : 0;
            if (type === 'FLYING_ROCK') { this.y = spawnY - 110; this.initialY = this.y; } else { this.initialY = this.y; }
            this.points = []; let numPoints = 6; for(let i=0; i<numPoints; i++) { let angle = (i/numPoints) * Math.PI * 2; let r = 20 + Math.random() * 10; this.points.push({x: Math.cos(angle) * r, y: Math.sin(angle) * r}); }
        }
        update() {
            // Warning Logic for Laser
            if (this.warningTimer > 0) {
                this.warningTimer--;
                if (this.warningTimer === 1) audio.playSFX('laser');
                return;
            }

            this.x -= (gameSpeed + this.speedX) * timeScale;
            
            if (this.type === 'FLYING_ROCK') this.y = this.initialY + Math.sin(frameCount * 0.1) * 20;
            else if (this.type === 'MISSILE' || this.type === 'ARROW') { 
                if (Math.random() < 0.05) this.vy = (Math.random() - 0.5) * 8; 
                this.y += (this.vy || 0) * timeScale; 
                this.y += Math.sin(this.x * 0.05) * 2 * timeScale;
            }
            else if (this.type === 'SEEKER_DRONE') {
                this.y += (player.y - this.y) * 0.02 * timeScale; // Homes in
            }
            else if (this.type === 'BAT_SWARM') {
                this.y = this.initialY + Math.sin(this.x * 0.05) * 40;
            }
            else if (this.type === 'GEYSER') {
                if(this.x < canvas.width - 100) {
                    if (this.isRising && this.height < 150) this.height += 5;
                    this.y = terrain.getSegmentAt(this.x).y - this.height;
                }
            }
            else if (this.type === 'GLITCH_PIXEL') {
                if (Math.random() < 0.1) this.y = this.initialY + (Math.random() - 0.5) * 100;
            }
            else if (this.type === 'SUN') this.y = this.initialY + Math.sin(frameCount * 0.05) * 50;
            else if (this.type === 'LAVA_PLUME') { if (this.x < canvas.width && this.y > this.targetY) this.y -= 10 * timeScale; }
            
            if (this.isMoving && this.type !== 'MISSILE' && this.type !== 'ARROW') { this.x -= 2.5 * timeScale; this.angle -= 0.15 * timeScale; }

            // QTE
            if (!this.qteTriggered && !qteActive) {
                let dist = this.x - player.x;
                if (dist > 50 && dist < 200) {
                    let reduction = Math.floor(score / 1000) * 90;
                    let calculatedMaxTime = 720 - reduction;
                    if (calculatedMaxTime >= 45) {
                        const triggerChance = 0.5;
                        if (['MISSILE', 'WAVE', 'LAVA_PLUME', 'ELECTRIC_GATE', 'LASER_BEAM'].includes(this.type)) {
                            if (Math.random() < triggerChance) {
                                let action = 'JUMP';
                                if (this.type === 'MISSILE' && this.y < canvas.height - 200) action = 'DIVE';
                                if (this.type === 'ELECTRIC_GATE') action = 'DIVE';
                                if (this.type === 'LASER_BEAM' && this.y < canvas.height - 200) action = 'DIVE';
                                
                                triggerQTE(action, this, calculatedMaxTime);
                            } else { this.qteTriggered = true; }
                        }
                    } else { this.qteTriggered = true; }
                }
            }
            for (let p of terrain.platforms) { if (this.x < p.x + p.width - 5 && this.x + this.width > p.x + 5 && this.y < p.y + p.height - 5 && this.y + this.height > p.y + 5) this.markedForDeletion = true; }
        }
        draw() {
            ctx.save();
            if (this.warningTimer > 0) {
                // Draw telegraph line
                ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random()})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, this.y + 5);
                ctx.lineTo(canvas.width, this.y + 5);
                ctx.stroke();
                ctx.restore();
                return;
            }

            if (['MISSILE', 'ARROW'].includes(this.type)) {
                ctx.fillStyle = this.type === 'ARROW' ? '#FFF' : '#E0E0E0'; 
                ctx.shadowColor = '#FF0000'; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.moveTo(this.x + this.width, this.y); ctx.lineTo(this.x, this.y + this.height/2); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.lineTo(this.x + this.width - 15, this.y + this.height/2); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = '#FF4444'; ctx.lineWidth = 3; ctx.stroke();
            } else if (this.type === 'SUN') {
                 ctx.fillStyle = '#E9C46A'; ctx.shadowColor = '#FFA500'; ctx.shadowBlur = 25; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 20, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
            } else if (['DRONE', 'DRAINER', 'NULLIFIER', 'SEEKER_DRONE'].includes(this.type)) {
                ctx.fillStyle = this.type === 'DRAINER' ? '#800080' : (this.type === 'NULLIFIER' ? '#555' : '#10FFD0'); 
                if(this.type === 'SEEKER_DRONE') ctx.fillStyle = '#FF0000';
                ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.moveTo(this.x, this.y + this.height / 2); ctx.lineTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;
            } else if (this.type === 'WAVE') {
                ctx.fillStyle = 'rgba(255, 0, 255, 0.3)'; ctx.shadowColor = '#FF00FF'; ctx.shadowBlur = 30; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height, this.width, Math.PI, 2 * Math.PI); ctx.fill(); ctx.beginPath(); ctx.rect(this.x, this.y + this.height / 2, this.width, 10); ctx.fillStyle = 'rgba(255, 0, 255, 0.6)'; ctx.fill(); ctx.shadowBlur = 0;
            } else if (this.type === 'LAVA_PLUME' || this.type === 'GEYSER') {
                ctx.fillStyle = this.type === 'GEYSER' ? '#00BFFF' : '#FF4500'; 
                ctx.fillRect(this.x, this.y, this.width, this.height);
            } 
            // New Types Drawing
            else if (this.type === 'ELECTRIC_GATE') {
                ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 4; ctx.strokeRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = `rgba(0, 255, 255, ${Math.random()})`; ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            else if (this.type === 'ROLLING_BOULDER') {
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(this.x+30, this.y+30, 30, 0, Math.PI*2); ctx.fill();
            }
            else if (this.type === 'BAT_SWARM') {
                ctx.fillStyle = '#000'; 
                for(let i=0; i<5; i++) { ctx.fillRect(this.x + i*15, this.y + Math.sin(frameCount*0.5 + i)*10, 10, 5); }
            }
            else if (this.type === 'LASER_BEAM') {
                ctx.fillStyle = '#FF0000'; ctx.shadowColor = '#FF0000'; ctx.shadowBlur = 20;
                ctx.fillRect(0, this.y, canvas.width, 10);
            }
            else if (this.type === 'GLITCH_PIXEL') {
                ctx.fillStyle = '#00FF00'; ctx.fillRect(this.x, this.y, this.width, this.height);
                if(Math.random()<0.5) ctx.strokeRect(this.x-5, this.y-5, this.width+10, this.height+10);
            }
            else if (this.type === 'RED_WALL') {
                ctx.fillStyle = '#FF0000'; ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            else if (this.type === 'SPIKE_CEILING') {
                ctx.fillStyle = '#888'; ctx.beginPath(); ctx.moveTo(this.x, 0); ctx.lineTo(this.x+50, 40); ctx.lineTo(this.x+100, 0); ctx.fill();
            }
            else {
                // Rock
                ctx.translate(this.x + this.width/2, this.y + this.height/2); if (this.isMoving) ctx.rotate(this.angle); ctx.fillStyle = '#4A5A6A'; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); for(let i=1; i<this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y); ctx.closePath(); ctx.fill(); ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 4; ctx.stroke();
            }
            ctx.restore();
        }
    }

    class Collectible {
        constructor() {
            this.width = 30; this.height = 30; this.x = canvas.width; this.y = Math.random() * (canvas.height * 0.6) + 50; 
            const r = Math.random();
            if (r < 0.4) this.type = 'SEAWEED'; else if (r < 0.6) this.type = 'WOOL'; else if (r < 0.9) this.type = 'COIN'; else this.type = 'MYSTERY';
        }
        update() {
            this.x -= gameSpeed * timeScale; this.y += Math.sin(frameCount * 0.1) * 0.5 * timeScale;
            if (buffs.magnet) { let dx = player.x - this.x; let dy = player.y - this.y; let dist = Math.sqrt(dx*dx + dy*dy); if (dist < 250) { this.x += dx * 0.05 * timeScale; this.y += dy * 0.05 * timeScale; } }
        }
        draw() {
            if (this.type === 'SEAWEED') { ctx.fillStyle = '#2A9D8F'; ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 10, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x+15, this.y+5); ctx.quadraticCurveTo(this.x+5, this.y+15, this.x+15, this.y+25); ctx.quadraticCurveTo(this.x+25, this.y+15, this.x+15, this.y+5); ctx.stroke(); } 
            else if (this.type === 'WOOL') { ctx.fillStyle = '#FFF'; ctx.shadowColor = '#FFF'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 12, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; } 
            else if (this.type === 'COIN') { ctx.fillStyle = '#FFD700'; ctx.strokeStyle = '#DAA520'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x + 15, this.y + 15, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#DAA520'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('$', this.x+15, this.y+19); } 
            else if (this.type === 'MYSTERY') { ctx.fillStyle = '#9932CC'; ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(this.x, this.y, 30, 30); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#FFF'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText('?', this.x+15, this.y+21); }
        }
    }

    class Particle {
        constructor(x, y, size, color) { this.x = x; this.y = y; this.size = size; this.color = color; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.life = 1.0; }
        update() { this.x += this.vx * timeScale; this.y += this.vy * timeScale; this.life -= 0.05 * timeScale; }
        draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
    }

    class Cloud {
        constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * (canvas.height * 0.5); this.speed = Math.random() * 0.5 + 0.1; this.width = 60 + Math.random() * 60; this.alpha = 0.3 + Math.random() * 0.4; }
        update() { this.x -= (this.speed + (gameSpeed * 0.05)) * timeScale; if (this.x + this.width < 0) this.x = canvas.width + 50; }
        draw() { ctx.fillStyle = `rgba(255,255,255,${this.alpha})`; ctx.beginPath(); ctx.roundRect(this.x, this.y, this.width, 30, 20); ctx.fill(); }
    }

    // --- Logic ---
    function init() {
        resize();
        audio.init(); 
        
        terrain = new TerrainManager();
        terrain.reset();
        weather = new WeatherSystem();

        player = new Player();
        obstacles = [];
        collectibles = [];
        particles = [];
        floatingTexts = [];
        score = 0;
        sessionCoins = 0;
        shakeTimer = 0;
        
        bossBattleActive = false;
        bossDefeated = false;
        postBossMode = false;
        winTriggered = false;
        boss = null;
        
        gameSpeed = DIFFICULTIES[selectedDifficulty].speed;
        
        frameCount = 0;
        dayTime = 0.3; 
        nextQuizThreshold = 700; 
        buffs = { magnet: false, shieldRegen: false, efficiency: false };
        qteActive = false;
        timeScale = 1.0;
        
        clouds = [];
        for(let i=0; i<8; i++) clouds.push(new Cloud());
        
        document.getElementById('hud-highscore').innerText = Math.floor(highScore);
        document.getElementById('boss-hud').style.display = 'none';
        document.getElementById('attack-btn').style.display = 'none';
        
        audio.startBGM();
    }

    function createParticles(x, y, count, color) {
        if (window.innerWidth < 768) count = Math.ceil(count / 2);
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, Math.random()*4+2, color));
    }

    function flashScreen() {
        const overlay = document.getElementById('damage-overlay');
        overlay.style.opacity = '1';
        setTimeout(() => { overlay.style.opacity = '0'; }, 100);
        shakeTimer = 10; 
    }
    
    // --- DIFFICULTY SYSTEM ---
    function cycleDifficulty() {
        let idx = DIFF_KEYS.indexOf(selectedDifficulty);
        idx = (idx + 1) % DIFF_KEYS.length;
        selectedDifficulty = DIFF_KEYS[idx];
        
        const btn = document.getElementById('diff-btn');
        btn.innerText = "Difficulty: " + DIFFICULTIES[selectedDifficulty].label;
        audio.playSFX('click');
    }

    // --- QUIZ LOGIC ---
    function triggerQuiz() {
        gameState = 'QUIZ';
        const qData = QUESTIONS[Math.floor(Math.random() * QUESTIONS.length)];
        
        document.getElementById('quiz-question').innerText = qData.q;
        const optsContainer = document.getElementById('quiz-options');
        optsContainer.innerHTML = '';
        
        qData.opts.forEach((opt, idx) => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-option';
            btn.innerText = opt;
            btn.onclick = () => handleQuizAnswer(idx === qData.ans);
            optsContainer.appendChild(btn);
        });

        showScreen('quiz-screen');
    }

    function handleQuizAnswer(isCorrect) {
        if (isCorrect) {
            sessionCoins += 50;
            audio.playSFX('powerup');
            showScreen('reward-screen');
        } else {
            gameState = 'PLAYING';
            showScreen('none');
            gameLoop();
        }
    }

    function applyBuff(type) {
        audio.playSFX('powerup');
        if (type === 'MAGNET') buffs.magnet = true;
        if (type === 'SHIELD_REGEN') {
            buffs.shieldRegen = true;
            if (player.shieldCount < player.maxShields) {
                player.shieldCount++;
                createParticles(player.x, player.y, 10, '#FFF');
            }
        }
        if (type === 'EFFICIENCY') buffs.efficiency = true;
        
        gameState = 'PLAYING';
        showScreen('none');
        gameLoop();
    }

    function triggerQTE(action, obstacle, maxTime) {
        if (qteActive) return;
        qteActive = true;
        qteTargetAction = action;
        qteTargetObstacle = obstacle;
        obstacle.qteTriggered = true;
        
        timeScale = 0.1; // SLOW MOTION
        qteMaxTime = maxTime;
        qteTimer = qteMaxTime;
        
        const overlay = document.getElementById('qte-overlay');
        const prompt = document.getElementById('qte-prompt');
        overlay.classList.add('active');
        prompt.innerText = action === 'JUMP' ? "TAP UP!" : "SWIPE DOWN!";
        audio.playSFX('slowmo');
    }

    function resolveQTE(success) {
        qteActive = false;
        const overlay = document.getElementById('qte-overlay');
        overlay.classList.remove('active');
        if (success) {
            timeScale = 1.0;
            if (qteTargetAction === 'JUMP') player.superJump();
            if (qteTargetAction === 'DIVE') player.superDive();
            if (qteTargetObstacle) { createParticles(qteTargetObstacle.x, qteTargetObstacle.y, 30, '#FFFFFF'); qteTargetObstacle.markedForDeletion = true; }
            spawnFloatingText(player.x, player.y - 50, "PERFECT!", "#00FFFF");
            energy = Math.min(maxEnergy, energy + 10);
        } else {
            timeScale = 1.0;
            spawnFloatingText(player.x, player.y - 50, "TOO SLOW!", "#E76F51");
        }
    }

    function handleQTEInput(inputAction) {
        if (!qteActive) return false;
        if (inputAction === qteTargetAction) { resolveQTE(true); return true; } else { return false; }
    }

    function spawnLogic() {
        if (bossBattleActive) return; 

        // Dynamic spawn rate based on speed. Faster = fewer spawns to prevent clutter.
        let spawnThreshold = 110 - (gameSpeed * 3); 
        if (postBossMode) spawnThreshold /= 2; 
        if (spawnThreshold < 15) spawnThreshold = 15; 
        
        if (frameCount % Math.floor(spawnThreshold) === 0) {
            const r = Math.random();
            const canSpawnFlyingRock = score > 300; 
            const canSpawnDrone = score > 750; 
            const canSpawnMissile = score > 1500;
            const canSpawnWave = score > 1800; 
            
            // New Mid-Game Enemies
            const canSpawnElectric = score > 3000;
            const canSpawnBoulder = score > 4000;
            const canSpawnGeyser = score > 5000;
            const canSpawnBat = score > 6000;

            // Post boss hard enemies
            const isHardMode = postBossMode;

            let type = 'ROCK';
            
            if (isHardMode) {
                let hardR = Math.random();
                if (hardR < 0.2) type = 'LASER_BEAM';
                else if (hardR < 0.4) type = 'GLITCH_PIXEL';
                else if (hardR < 0.6) type = 'SEEKER_DRONE';
                else if (hardR < 0.8) type = 'RED_WALL';
                else type = 'SPIKE_CEILING';
            } else {
                if (canSpawnBat && r < 0.1) type = 'BAT_SWARM';
                else if (canSpawnGeyser && r < 0.2) type = 'GEYSER';
                else if (canSpawnBoulder && r < 0.3) type = 'ROLLING_BOULDER';
                else if (canSpawnElectric && r < 0.4) type = 'ELECTRIC_GATE';
                else if (canSpawnWave && r < 0.5) type = 'WAVE';
                else if (canSpawnMissile && r < 0.6) type = 'MISSILE';
                else if (canSpawnDrone && r < 0.7) type = 'DRONE';
                else if (canSpawnFlyingRock && r < 0.8) type = 'FLYING_ROCK';
                else if (r < 0.9) type = 'SUN'; 
                else type = 'ROCK';
            }
            
            // Check for Platform Collision
            let spawnX = canvas.width + 100;
            let safeToSpawn = true;
            for(let p of terrain.platforms) {
                if (spawnX < p.x + p.width + 50 && spawnX + 40 > p.x - 50) {
                    safeToSpawn = false;
                    break;
                }
            }

            if (safeToSpawn) {
                obstacles.push(new Obstacle(type));
            }
        }
        
        if (frameCount % 150 === 0) {
            if (Math.random() > 0.3) collectibles.push(new Collectible());
        }
    }

    function drawEnvironment() {
        if (postBossMode) {
             ctx.fillStyle = '#050505'; // Almost Black
             ctx.fillRect(0,0,canvas.width,canvas.height);
        } else {
             dayTime = (dayTime + 0.0005 * timeScale) % 1.0; 
             let topC, botC;
             if (dayTime < 0.25) { let t = dayTime / 0.25; topC = lerpColor(SKY_COLORS.dawn.top, SKY_COLORS.noon.top, t); botC = lerpColor(SKY_COLORS.dawn.bot, SKY_COLORS.noon.bot, t); } 
             else if (dayTime < 0.5) { let t = (dayTime - 0.25) / 0.25; topC = lerpColor(SKY_COLORS.noon.top, SKY_COLORS.dusk.top, t); botC = lerpColor(SKY_COLORS.noon.bot, SKY_COLORS.dusk.bot, t); } 
             else if (dayTime < 0.75) { let t = (dayTime - 0.5) / 0.25; topC = lerpColor(SKY_COLORS.dusk.top, SKY_COLORS.night.top, t); botC = lerpColor(SKY_COLORS.dusk.bot, SKY_COLORS.night.bot, t); } 
             else { let t = (dayTime - 0.75) / 0.25; topC = lerpColor(SKY_COLORS.night.top, SKY_COLORS.dawn.top, t); botC = lerpColor(SKY_COLORS.night.bot, SKY_COLORS.dawn.bot, t); }
             let skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height); skyGradient.addColorStop(0, topC); skyGradient.addColorStop(1, botC); ctx.fillStyle = skyGradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        if (shakeTimer > 0) { ctx.save(); let dx = (Math.random() - 0.5) * 10; let dy = (Math.random() - 0.5) * 10; ctx.translate(dx, dy); shakeTimer--; }

        bgLayers.forEach(layer => { layer.update(); layer.draw(ctx); });
        clouds.forEach(c => { c.update(); c.draw(); });

        terrain.update();
        terrain.draw(ctx);
        if (bossBattleActive && boss) boss.draw(ctx);
        weather.update();
        weather.draw(ctx);

        if (shakeTimer >= 0) ctx.restore();
    }

    function checkCollisions() {
        const padding = 10; // Tighter Hitbox
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            if (obs.x + obs.width < -100) { obstacles.splice(i, 1); continue; }

            // Precise Hitbox Logic
            let hitX = player.x + padding < obs.x + obs.width - padding && player.x + player.width - padding > obs.x + padding;
            let hitY = player.y + padding < obs.y + obs.height - padding && player.y + player.height - padding > obs.y + padding;

            if (hitX && hitY) {
                if (invulnerableTimer > 0) continue;
                if (player.shieldCount > 0) {
                    player.shieldCount--; obstacles.splice(i, 1); createParticles(player.x, player.y, 10, player.skin.color); flashScreen(); audio.playSFX('crash'); spawnFloatingText(player.x, player.y - 30, "Shield Lost", "#FFF");
                } else {
                    let dmg = obs.damage;
                    let particleColor = PALETTE.danger;
                    let endMessage = 'Impact!';
                    if (obs.type === 'DRAINER') { dmg = 20; endMessage = 'Drained'; energy -= 20; }
                    else if (obs.type === 'NULLIFIER') { buffs = { magnet: false, shieldRegen: false, efficiency: false }; spawnFloatingText(player.x, player.y, "BUFFS WIPED", "#FFF"); dmg = 10; }
                    
                    flashScreen(); audio.playSFX('crash'); energy -= dmg; createParticles(player.x, player.y, 8, particleColor); obstacles.splice(i, 1); spawnFloatingText(player.x, player.y - 30, "-" + Math.floor(dmg) + " Energy", "#E76F51");
                    if (energy <= 0) endGame(endMessage); 
                }
            }
        }
        // Collectibles
        const itemPadding = 15;
        for (let i = collectibles.length - 1; i >= 0; i--) {
            let c = collectibles[i];
            let hit = player.x < c.x + c.width + itemPadding && player.x + player.width > c.x - itemPadding && player.y < c.y + c.height + itemPadding && player.y + player.height > c.y - itemPadding;
            if (hit) {
                collectibles.splice(i, 1);
                if (c.type === 'SEAWEED') { audio.playSFX('coin'); let amount = 20; if (player.skin.perk === 'eco_boost') amount = 40; energy = Math.min(maxEnergy, energy + amount); createParticles(c.x, c.y, 5, '#2A9D8F'); spawnFloatingText(c.x, c.y, "+" + amount + " Energy", "#2A9D8F"); } 
                else if (c.type === 'WOOL') { audio.playSFX('coin'); if (player.shieldCount < player.maxShields) { player.shieldCount++; createParticles(c.x, c.y, 5, '#FFF'); spawnFloatingText(c.x, c.y, "Shield Up", "#FFF"); } } 
                else if (c.type === 'COIN') { audio.playSFX('coin'); sessionCoins += 10; createParticles(c.x, c.y, 5, '#FFD700'); spawnFloatingText(c.x, c.y, "+10 Coins", "#FFD700"); } 
                else if (c.type === 'MYSTERY') { audio.playSFX('mystery'); if(!player.hasSword && bossBattleActive) { player.hasSword = true; spawnFloatingText(player.x, player.y, "SWORD EQUIPPED", "#00FFFF"); } else { sessionCoins+=50; spawnFloatingText(player.x, player.y, "+50 Coins", "#FFD700"); } }
            }
        }
    }

    function gameLoop() {
        if (gameState !== 'PLAYING') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (qteActive) {
            qteTimer -= 1; 
            const fill = document.getElementById('qte-timer-fill'); fill.style.width = (qteTimer / qteMaxTime * 100) + "%";
            if (qteTimer <= 0) { resolveQTE(false); }
        }
        
        frameCount++;
        let diffSettings = DIFFICULTIES[selectedDifficulty];
        
        // Progression Logic
        if (!bossBattleActive && gameSpeed < MAX_SPEED) {
            gameSpeed += diffSettings.progression * timeScale; // Smooth linear increase
            score += (gameSpeed * timeScale * 0.05);
        }
        
        // CHECK BOSS TRIGGER
        if (score > 7000 && !bossDefeated && !bossBattleActive) {
            bossBattleActive = true;
            boss = new Boss();
            document.getElementById('boss-hud').style.display = 'flex';
            document.getElementById('attack-btn').style.display = 'none'; // Only show sword button if collected
            player.hasSword = false; // Reset sword state for boss fight start
            player.vx = 0; // Reset velocity
            spawnFloatingText(player.x, player.y, "BOSS BATTLE START!", "#FF0000");
            obstacles = []; 
        }
        
        // CHECK WIN
        if (score > 20000 && !winTriggered) {
            winTriggered = true;
            unlockBadge('legend');
            gameState = 'WIN';
            showScreen('win-screen');
            return;
        }

        if (score >= 1000) unlockBadge('novice');
        if (score >= 5000) unlockBadge('runner');
        
        // Quiz Trigger Logic
        if (score >= nextQuizThreshold && !qteActive && !bossBattleActive) {
            nextQuizThreshold += 700; 
            triggerQuiz();
            return; 
        }

        if (frameCount % 60 === 0) {
            let drain = diffSettings.drain * timeScale;
            if (buffs.efficiency) drain *= 0.5;
            energy -= drain;
        }
        if (energy <= 0) { endGame('Out of Energy'); return; }

        player.update();
        if (bossBattleActive && boss) boss.update();
        spawnLogic();
        drawEnvironment();

        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].update();
            if (obstacles[i].markedForDeletion) { obstacles.splice(i, 1); } 
            else if (obstacles[i].x + obstacles[i].width > -100) { obstacles[i].draw(); } 
            else { obstacles.splice(i, 1); }
        }
        for (let i = collectibles.length - 1; i >= 0; i--) { collectibles[i].update(); if (collectibles[i].x + collectibles[i].width > -100) collectibles[i].draw(); else collectibles.splice(i, 1); }
        for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if (particles[i].life > 0) particles[i].draw(); else particles.splice(i, 1); }
        for (let i = floatingTexts.length - 1; i >= 0; i--) { floatingTexts[i].update(); if (floatingTexts[i].life > 0) floatingTexts[i].draw(ctx); else floatingTexts.splice(i, 1); }

        player.draw();
        checkCollisions();
        
        // Update Attack Button Visibility
        if (bossBattleActive) {
            document.getElementById('attack-btn').style.display = player.hasSword ? 'flex' : 'none';
        }


        document.getElementById('score').innerText = Math.floor(score);
        document.getElementById('hud-highscore').innerText = Math.floor(highScore); 
        const bar = document.getElementById('energy-fill');
        bar.style.width = Math.max(0, (energy / maxEnergy) * 100) + '%';
        if (energy < 30) bar.style.background = PALETTE.danger; else bar.style.background = `linear-gradient(90deg, #2A9D8F, #2F6F6F)`;

        frameId = requestAnimationFrame(gameLoop);
    }

    // --- State Management ---
    function startGame() { showScreen('none'); init(); gameState = 'PLAYING'; gameLoop(); audio.playSFX('powerup'); }
    function endGame(reason) {
        gameState = 'GAMEOVER'; cancelAnimationFrame(frameId); audio.stopBGM(); audio.playSFX('crash');
        let earned = Math.floor(score / 10) + sessionCoins; playerData.coins += earned;
        if (score > highScore) { highScore = score; localStorage.setItem('aether_highscore_v4', highScore); }
        if (playerData.coins >= 1000) unlockBadge('rich');
        saveGame();
        document.getElementById('final-score').innerText = Math.floor(score) + "m"; document.getElementById('game-over-best').innerText = Math.floor(highScore) + "m"; document.getElementById('coins-earned').innerText = "+" + earned + " Coins"; document.getElementById('game-over-msg').innerText = reason; showScreen('game-over-screen');
    }
    function continueEndless() { gameState = 'PLAYING'; showScreen('none'); gameLoop(); }
    function resetGame() { startGame(); }
    function openShop() { showScreen('shop-screen'); renderShop(); }
    
    function playerAttack() {
        if(gameState === 'PLAYING' && player.hasSword) player.attack();
    }
    
    function renderShop() {
        const container = document.getElementById('shop-container'); container.innerHTML = '';
        SKINS.forEach(skin => {
            const owned = playerData.ownedSkins.includes(skin.id); const equipped = playerData.equippedSkin === skin.id; const div = document.createElement('div'); div.className = `shop-item ${equipped ? 'active' : ''}`; div.onclick = () => handleShopClick(skin.id);
            let btnLabel = owned ? (equipped ? 'EQUIPPED' : 'EQUIP') : `${skin.cost} ü™ô`; let btnClass = owned ? 'owned-tag' : 'skin-price'; if (equipped) btnClass += ' active-tag'; 
            div.innerHTML = `<div class="skin-preview" style="background:${skin.color}; border-color:${skin.secondary}"></div><div class="skin-name">${skin.name}</div><div class="skin-perk">${skin.desc}</div><div class="${btnClass}">${btnLabel}</div>`; container.appendChild(div);
        });
    }
    function showModal(msg, onConfirm) { const modal = document.getElementById('custom-modal'); const msgEl = document.getElementById('modal-msg'); const actionBtn = document.getElementById('modal-action-btn'); const closeBtn = document.getElementById('modal-close-btn'); msgEl.innerText = msg; modal.classList.remove('hidden'); if (onConfirm) { actionBtn.innerText = "Confirm"; closeBtn.style.display = "inline-block"; actionBtn.onclick = () => { onConfirm(); modal.classList.add('hidden'); }; } else { actionBtn.innerText = "OK"; closeBtn.style.display = "none"; actionBtn.onclick = () => { modal.classList.add('hidden'); }; } closeBtn.onclick = () => modal.classList.add('hidden'); }
    function handleShopClick(id) { const skin = SKINS.find(s => s.id === id); const owned = playerData.ownedSkins.includes(id); if (owned) { playerData.equippedSkin = id; saveGame(); renderShop(); audio.playSFX('click'); } else { if (playerData.coins >= skin.cost) { showModal(`Buy ${skin.name} for ${skin.cost} Coins?`, () => { playerData.coins -= skin.cost; playerData.ownedSkins.push(id); playerData.equippedSkin = id; saveGame(); renderShop(); audio.playSFX('powerup'); }); } else { showModal("Not enough coins! Keep running!"); audio.playSFX('click'); } } }
    function showScreen(id) { document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden')); if(id !== 'none') document.getElementById(id).classList.remove('hidden'); }

    window.addEventListener('keydown', (e) => {
        // --- BOSS CONTROLS (WASD) ---
        if (bossBattleActive) {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') player.vx = -10;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') player.vx = 10;
            if (e.code === 'KeyF') player.attack();
        }

        // --- GENERAL CONTROLS (Space, Up, W, Down, S) ---
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { 
            e.preventDefault(); 
            if (qteActive) { handleQTEInput('JUMP'); } 
            else if (gameState === 'PLAYING') { player.jump(); } 
        }
        if (e.code === 'ArrowDown' || e.code === 'KeyS') { 
            e.preventDefault(); 
            if (qteActive) { handleQTEInput('DIVE'); } 
            else if (gameState === 'PLAYING') { player.dive(); } 
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft' || e.code === 'ArrowRight' || e.code === 'KeyA' || e.code === 'KeyD') player.vx = 0;
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { 
            if (gameState === 'PLAYING' && !qteActive) player.cutJump(); 
        }
    });
    
    // Touch controls for Boss
    window.addEventListener('touchstart', (e) => {
        if (gameState !== 'PLAYING' || e.target.closest('button') || e.target.id === 'attack-btn') return;
        e.preventDefault(); window.touchStartY = e.changedTouches[0].clientY;
        if (qteActive && qteTargetAction === 'JUMP') handleQTEInput('JUMP');
        
        // Mobile Boss Movement
        if (bossBattleActive) {
            if (e.changedTouches[0].clientX < window.innerWidth / 2) player.vx = -10;
            else player.vx = 10;
        }
    }, {passive: false});
    
    window.addEventListener('touchend', (e) => {
        if (gameState !== 'PLAYING') return;
        if(e.target.tagName === 'BUTTON' || e.target.id === 'attack-btn') return;
        e.preventDefault();
        
        if (bossBattleActive) player.vx = 0; // Stop X movement

        let deltaY = e.changedTouches[0].clientY - window.touchStartY;
        if (qteActive) { if (deltaY > 30 && qteTargetAction === 'DIVE') handleQTEInput('DIVE'); return; }
        if (gameState === 'PLAYING') player.cutJump();
        if (deltaY > 30) { if (gameState === 'PLAYING') player.dive(); } 
        else { if (gameState === 'PLAYING') player.jump(); }
    });
    
    window.addEventListener('mousedown', (e) => { 
        if(e.target.tagName !== 'BUTTON' && e.target.id !== 'attack-btn' && gameState === 'PLAYING') {
            if (qteActive && qteTargetAction === 'JUMP') handleQTEInput('JUMP');
            else player.attack(); // Left click to attack
        }
    });
    window.addEventListener('mouseup', (e) => { if(gameState === 'PLAYING' && !qteActive) player.cutJump(); });

    resize();
    updateCoinDisplays();
    renderBadges();
</script>
</body>
</html>
